<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Pong Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #ff69b4, #ff1493, #c71585);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Arial', sans-serif;
        }

        .game-container {
            text-align: center;
            background: rgba(255, 182, 193, 0.2);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(199, 21, 133, 0.4);
            backdrop-filter: blur(10px);
        }

        h1 {
            color: #ff69b4;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(199, 21, 133, 0.7);
            animation: rainbow-text 2s linear infinite;
        }

        @keyframes rainbow-text {
            0% {
                color: #ff0000;
            }

            16% {
                color: #ff8000;
            }

            33% {
                color: #ffff00;
            }

            50% {
                color: #00ff00;
            }

            66% {
                color: #0080ff;
            }

            83% {
                color: #8000ff;
            }

            100% {
                color: #ff0000;
            }
        }

        #gameCanvas {
            border: 3px solid #ff69b4;
            border-radius: 10px;
            background: #1a0a1a;
            box-shadow: 0 4px 20px rgba(199, 21, 133, 0.6);
            max-width: 100%;
            height: auto;
        }

        @media (max-width: 900px) {
            #gameCanvas {
                width: 90vw;
                height: 45vw;
            }
        }

        .controls {
            color: #ffb6c1;
            margin-top: 15px;
            font-size: 14px;
        }

        .score {
            color: #ff69b4;
            font-size: 24px;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(199, 21, 133, 0.7);
            animation: bounce 1s ease-in-out infinite alternate;
        }

        @keyframes bounce {
            0% {
                transform: translateY(0px);
            }

            100% {
                transform: translateY(-5px);
            }
        }

        .game-over {
            color: #ff1493;
            font-size: 28px;
            margin-top: 15px;
            text-shadow: 2px 2px 4px rgba(199, 21, 133, 0.7);
            animation: rainbow-text 1s linear infinite, pulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            100% {
                transform: scale(1.1);
            }
        }

        button {
            background: linear-gradient(45deg, #ff69b4, #ff1493);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 10px;
            box-shadow: 0 4px 15px rgba(199, 21, 133, 0.3);
            transition: transform 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(199, 21, 133, 0.5);
        }
    </style>
</head>

<body>
    <div class="game-container">
        <h1>ðŸŒˆðŸ’– PONG ðŸ’–ðŸŒˆ</h1>
        <div class="score">
            ðŸŒˆðŸ’– Player 1: <span id="player1Score">0</span> ðŸ’–ðŸŒˆ | ðŸŒˆðŸ’– Player 2: <span id="player2Score">0</span> ðŸ’–ðŸŒˆ
        </div>
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        <div class="controls">
            <p><strong>ðŸŒˆðŸ’– Player 1:</strong> W (up) / S (down) ðŸ’–ðŸŒˆ</p>
            <p><strong>ðŸŒˆðŸ’– Player 2:</strong> â†‘ (up) / â†“ (down) ðŸ’–ðŸŒˆ</p>
            <p><strong>ðŸŒˆðŸ’– Space:</strong> Pause/Resume ðŸ’–ðŸŒˆ</p>
            <p><strong>ðŸŒˆðŸ’– Mobile:</strong> Tap left/right sides of screen ðŸ’–ðŸŒˆ</p>
        </div>
        <div id="gameOver" class="game-over" style="display: none;"></div>
        <div style="margin-top: 15px;">
            <button onclick="resetGame()">ðŸŒˆðŸ’– New Game ðŸ’–ðŸŒˆ</button>
            <button onclick="setGameMode('pvp')" id="pvpBtn" style="margin-left: 10px;">ðŸŒˆðŸ’– Player vs Player ðŸ’–ðŸŒˆ</button>
            <button onclick="setGameMode('pvc')" id="pvcBtn" style="margin-left: 10px;">ðŸŒˆðŸ’– Player vs Computer ðŸ’–ðŸŒˆ</button>
        </div>
    </div>

    <script>
        // Game variables
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let gameRunning = true;
        let gamePaused = false;
        let player1Score = 0;
        let player2Score = 0;
        const winningScore = 10;

        // Paddle properties
        const paddleWidth = 15;
        const paddleHeight = 80;
        const paddleSpeed = 8;

        // Player 1 paddle (left)
        let player1 = {
            x: 20,
            y: canvas.height / 2 - paddleHeight / 2,
            width: paddleWidth,
            height: paddleHeight,
            speed: paddleSpeed
        };

        // Player 2 paddle (right)
        let player2 = {
            x: canvas.width - 20 - paddleWidth,
            y: canvas.height / 2 - paddleHeight / 2,
            width: paddleWidth,
            height: paddleHeight,
            speed: paddleSpeed
        };

        // Ball properties
        let ball = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 10,
            speedX: 6,
            speedY: 6,
            color: '#ff69b4',
            trail: []
        };

        // Input handling
        const keys = {};
        
        // Input reversal state
        let inputReversed = false;
        let reversalEndTime = 0;
        const reversalDuration = 1500; // 1.5 seconds
        
        // Game mode
        let gameMode = 'pvp'; // 'pvp' for player vs player, 'pvc' for player vs computer

        document.addEventListener('keydown', (e) => {
            const wasAlreadyPressed = keys[e.key.toLowerCase()];
            keys[e.key.toLowerCase()] = true;

            // Prevent default behavior for game controls
            if (e.key === ' ' || e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key.toLowerCase() === 'w' || e.key.toLowerCase() === 's') {
                e.preventDefault();
            }

            // Space bar to pause/resume
            if (e.key === ' ') {
                gamePaused = !gamePaused;
            }
            
            // Check for input reversal on new key press (not repeat)
            if (!wasAlreadyPressed && (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key.toLowerCase() === 'w' || e.key.toLowerCase() === 's')) {
                // Only trigger reversal if not already reversed AND players are in bounds
                const player1InBounds = player1.y >= 0 && player1.y <= canvas.height - player1.height;
                const player2InBounds = player2.y >= 0 && player2.y <= canvas.height - player2.height;
                
                if (!inputReversed && player1InBounds && player2InBounds && Math.random() < 0.15) {
                    inputReversed = true;
                    reversalEndTime = Date.now() + reversalDuration;
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Touch controls for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;

            // Left side for Player 1, right side for Player 2
            if (x < canvas.width / 2) {
                // Player 1 - move up
                keys['w'] = true;
                setTimeout(() => keys['w'] = false, 100);
            } else {
                // Player 2 - move up
                keys['arrowup'] = true;
                setTimeout(() => keys['arrowup'] = false, 100);
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            // Reset keys when touch ends
            keys['w'] = false;
            keys['s'] = false;
            keys['arrowup'] = false;
            keys['arrowdown'] = false;
        });

        // Game functions
        function updatePaddles() {
            // Check if reversal period has expired
            if (inputReversed && Date.now() >= reversalEndTime) {
                inputReversed = false;
            }
            
            // Player 1 controls (W/S)
            if (keys['w']) {
                const normalMovement = -player1.speed;
                const reversedMovement = player1.speed;
                const movement = inputReversed ? reversedMovement : normalMovement;
                
                if (inputReversed) {
                    // During reversal, allow movement out of bounds
                    player1.y += movement;
                } else {
                    // Normal movement - check bounds
                    if (player1.y > 0) {
                        player1.y += movement;
                    }
                }
            }
            if (keys['s']) {
                const normalMovement = player1.speed;
                const reversedMovement = -player1.speed;
                const movement = inputReversed ? reversedMovement : normalMovement;
                
                if (inputReversed) {
                    // During reversal, allow movement out of bounds
                    player1.y += movement;
                } else {
                    // Normal movement - check bounds
                    if (player1.y < canvas.height - player1.height) {
                        player1.y += movement;
                    }
                }
            }

            // Player 2 controls - either human or computer
            if (gameMode === 'pvp') {
                // Human player controls (Arrow keys)
                if (keys['arrowup']) {
                    const normalMovement = -player2.speed;
                    const reversedMovement = player2.speed;
                    const movement = inputReversed ? reversedMovement : normalMovement;
                    
                    if (inputReversed) {
                        // During reversal, allow movement out of bounds
                        player2.y += movement;
                    } else {
                        // Normal movement - check bounds
                        if (player2.y > 0) {
                            player2.y += movement;
                        }
                    }
                }
                if (keys['arrowdown']) {
                    const normalMovement = player2.speed;
                    const reversedMovement = -player2.speed;
                    const movement = inputReversed ? reversedMovement : normalMovement;
                    
                    if (inputReversed) {
                        // During reversal, allow movement out of bounds
                        player2.y += movement;
                    } else {
                        // Normal movement - check bounds
                        if (player2.y < canvas.height - player2.height) {
                            player2.y += movement;
                        }
                    }
                }
            } else {
                // Computer AI for Player 2
                const paddleCenter = player2.y + player2.height / 2;
                const ballCenter = ball.y;
                const aiSpeed = player2.speed * 0.8; // Slightly slower than human player
                
                if (paddleCenter < ballCenter - 10) {
                    // Move down
                    const normalMovement = aiSpeed;
                    const reversedMovement = -aiSpeed;
                    const movement = inputReversed ? reversedMovement : normalMovement;
                    
                    if (inputReversed) {
                        // During reversal, allow movement out of bounds
                        player2.y += movement;
                    } else {
                        // Normal movement - check bounds
                        if (player2.y < canvas.height - player2.height) {
                            player2.y += movement;
                        }
                    }
                } else if (paddleCenter > ballCenter + 10) {
                    // Move up
                    const normalMovement = -aiSpeed;
                    const reversedMovement = aiSpeed;
                    const movement = inputReversed ? reversedMovement : normalMovement;
                    
                    if (inputReversed) {
                        // During reversal, allow movement out of bounds
                        player2.y += movement;
                    } else {
                        // Normal movement - check bounds
                        if (player2.y > 0) {
                            player2.y += movement;
                        }
                    }
                }
            }
        }

        function updateBall() {
            ball.x += ball.speedX;
            ball.y += ball.speedY;

            // Ball collision with top and bottom walls
            if (ball.y - ball.radius <= 0 || ball.y + ball.radius >= canvas.height) {
                ball.speedY = -ball.speedY;
            }

            // Ball collision with paddles
            // Player 1 paddle collision
            if (ball.x - ball.radius <= player1.x + player1.width &&
                ball.y >= player1.y &&
                ball.y <= player1.y + player1.height &&
                ball.speedX < 0) {
                ball.speedX = -ball.speedX;
                // Add some angle based on where the ball hits the paddle
                let hitPos = (ball.y - player1.y) / player1.height;
                ball.speedY = (hitPos - 0.5) * 10;
            }

            // Player 2 paddle collision
            if (ball.x + ball.radius >= player2.x &&
                ball.y >= player2.y &&
                ball.y <= player2.y + player2.height &&
                ball.speedX > 0) {
                ball.speedX = -ball.speedX;
                // Add some angle based on where the ball hits the paddle
                let hitPos = (ball.y - player2.y) / player2.height;
                ball.speedY = (hitPos - 0.5) * 10;
            }

            // Ball out of bounds - scoring
            if (ball.x < 0) {
                player2Score++;
                resetBall();
                updateScore();
            } else if (ball.x > canvas.width) {
                player1Score++;
                resetBall();
                updateScore();
            }
        }

        function resetBall() {
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
            ball.speedX = (Math.random() > 0.5 ? 1 : -1) * 6;
            ball.speedY = (Math.random() - 0.5) * 6;
        }

        function updateScore() {
            document.getElementById('player1Score').textContent = player1Score;
            document.getElementById('player2Score').textContent = player2Score;

            // Check for winner
            if (player1Score >= winningScore || player2Score >= winningScore) {
                gameRunning = false;
                const winner = player1Score >= winningScore ? 'ðŸŒˆðŸ’– Player 1 ðŸ’–ðŸŒˆ' : 'ðŸŒˆðŸ’– Player 2 ðŸ’–ðŸŒˆ';
                document.getElementById('gameOver').textContent = `${winner} Wins! ðŸŽ‰ðŸŽŠ`;
                document.getElementById('gameOver').style.display = 'block';
            }
        }

        function setGameMode(mode) {
            gameMode = mode;
            updateGameModeDisplay();
            resetGame();
        }

        function updateGameModeDisplay() {
            const controls = document.querySelector('.controls');
            const pvpBtn = document.getElementById('pvpBtn');
            const pvcBtn = document.getElementById('pvcBtn');
            
            if (gameMode === 'pvp') {
                controls.innerHTML = `
                    <p><strong>ðŸŒˆðŸ’– Player 1:</strong> W (up) / S (down) ðŸ’–ðŸŒˆ</p>
                    <p><strong>ðŸŒˆðŸ’– Player 2:</strong> â†‘ (up) / â†“ (down) ðŸ’–ðŸŒˆ</p>
                    <p><strong>ðŸŒˆðŸ’– Space:</strong> Pause/Resume ðŸ’–ðŸŒˆ</p>
                    <p><strong>ðŸŒˆðŸ’– Mobile:</strong> Tap left/right sides of screen ðŸ’–ðŸŒˆ</p>
                `;
                pvpBtn.style.background = 'linear-gradient(45deg, #ff1493, #ff69b4)';
                pvcBtn.style.background = 'linear-gradient(45deg, #ff69b4, #ff1493)';
            } else {
                controls.innerHTML = `
                    <p><strong>ðŸŒˆðŸ’– Player:</strong> W (up) / S (down) ðŸ’–ðŸŒˆ</p>
                    <p><strong>ðŸŒˆðŸ’– Computer:</strong> AI controlled ðŸ’–ðŸŒˆ</p>
                    <p><strong>ðŸŒˆðŸ’– Space:</strong> Pause/Resume ðŸ’–ðŸŒˆ</p>
                    <p><strong>ðŸŒˆðŸ’– Mobile:</strong> Tap left side of screen ðŸ’–ðŸŒˆ</p>
                `;
                pvpBtn.style.background = 'linear-gradient(45deg, #ff69b4, #ff1493)';
                pvcBtn.style.background = 'linear-gradient(45deg, #ff1493, #ff69b4)';
            }
        }

        function resetGame() {
            player1Score = 0;
            player2Score = 0;
            gameRunning = true;
            gamePaused = false;
            document.getElementById('gameOver').style.display = 'none';
            resetBall();
            updateScore();

            // Reset paddle positions
            player1.y = canvas.height / 2 - paddleHeight / 2;
            player2.y = canvas.height / 2 - paddleHeight / 2;
        }

        function drawRainbowPaddle(x, y, width, height) {
            const colors = ['#ff0000', '#ff8000', '#ffff00', '#80ff00', '#00ff00', '#00ff80', '#00ffff', '#0080ff', '#0000ff', '#8000ff', '#ff00ff', '#ff0080'];
            const segmentHeight = height / colors.length;

            for (let i = 0; i < colors.length; i++) {
                ctx.fillStyle = colors[i];
                ctx.fillRect(x, y + (i * segmentHeight), width, segmentHeight);
            }

            // Add sparkle effect
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let i = 0; i < 5; i++) {
                const sparkleX = x + Math.random() * width;
                const sparkleY = y + Math.random() * height;
                ctx.fillRect(sparkleX, sparkleY, 2, 2);
            }
        }

        function drawStar(x, y, radius, spikes) {
            ctx.save();
            ctx.translate(x, y);
            ctx.beginPath();

            const outerRadius = radius;
            const innerRadius = radius * 0.4;

            for (let i = 0; i < spikes * 2; i++) {
                const angle = (i * Math.PI) / spikes;
                const r = i % 2 === 0 ? outerRadius : innerRadius;
                const px = Math.cos(angle) * r;
                const py = Math.sin(angle) * r;

                if (i === 0) {
                    ctx.moveTo(px, py);
                } else {
                    ctx.lineTo(px, py);
                }
            }

            ctx.closePath();
            ctx.restore();
        }

        function drawBallTrail() {
            // Add current position to trail
            ball.trail.push({ x: ball.x, y: ball.y, alpha: 1 });

            // Limit trail length
            if (ball.trail.length > 15) {
                ball.trail.shift();
            }

            // Draw trail with fading effect
            for (let i = 0; i < ball.trail.length; i++) {
                const point = ball.trail[i];
                const alpha = point.alpha * (i / ball.trail.length);

                // Rainbow trail effect
                const hue = (Date.now() * 0.01 + i * 20) % 360;
                ctx.fillStyle = `hsla(${hue}, 100%, 50%, ${alpha})`;

                ctx.save();
                ctx.translate(point.x, point.y);
                ctx.scale(1 - i / ball.trail.length, 1 - i / ball.trail.length);
                drawStar(0, 0, ball.radius, 5);
                ctx.fill();
                ctx.restore();
            }
        }

        function drawStarBall() {
            // Draw trail first
            drawBallTrail();

            // Draw main star with rainbow effect
            const gradient = ctx.createRadialGradient(ball.x, ball.y, 0, ball.x, ball.y, ball.radius);
            gradient.addColorStop(0, `hsl(${(Date.now() * 0.01) % 360}, 100%, 70%)`);
            gradient.addColorStop(1, `hsl(${(Date.now() * 0.01 + 60) % 360}, 100%, 50%)`);

            ctx.fillStyle = gradient;
            drawStar(ball.x, ball.y, ball.radius, 5);
            ctx.fill();

            // Add sparkle effect
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            drawStar(ball.x - 3, ball.y - 3, 3, 5);
            ctx.fill();
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = '#1a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw center line
            ctx.setLineDash([10, 10]);
            ctx.strokeStyle = '#ff69b4';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw rainbow paddles
            drawRainbowPaddle(player1.x, player1.y, player1.width, player1.height);
            drawRainbowPaddle(player2.x, player2.y, player2.width, player2.height);

            // Draw star ball
            drawStarBall();

            // Draw pause message
            if (gamePaused) {
                ctx.fillStyle = 'rgba(26, 10, 26, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ff69b4';
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ðŸŒˆðŸ’– PAUSED ðŸ’–ðŸŒˆ', canvas.width / 2, canvas.height / 2);
                ctx.font = '24px Arial';
                ctx.fillText('ðŸŒˆðŸ’– Press SPACE to resume ðŸ’–ðŸŒˆ', canvas.width / 2, canvas.height / 2 + 50);
            }
        }

        function gameLoop() {
            if (gameRunning && !gamePaused) {
                updatePaddles();
                updateBall();
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Initialize game mode display
        updateGameModeDisplay();

        // Start the game
        gameLoop();

        // Prevent context menu on right click
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
    </script>
</body>

</html>