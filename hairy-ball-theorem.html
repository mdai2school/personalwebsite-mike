<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Hairy Ball Theorem</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: auto;
            position: relative;
            color: #00ff00;
        }

        /* Game-like border effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 8px solid #00ff00;
            box-shadow: 
                0 0 20px #00ff00,
                inset 0 0 20px rgba(0, 255, 0, 0.1);
            pointer-events: none;
            z-index: 1;
        }

        /* Corner decorations */
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                linear-gradient(90deg, #00ff00 2px, transparent 2px),
                linear-gradient(180deg, #00ff00 2px, transparent 2px);
            background-size: 40px 40px;
            opacity: 0.1;
            pointer-events: none;
            z-index: 0;
        }

        .game-container {
            position: relative;
            z-index: 2;
            max-width: 900px;
            width: 90%;
            margin: 40px auto;
            background: #1a1a2e;
            border: 4px solid #00ff00;
            box-shadow: 
                0 0 30px rgba(0, 255, 0, 0.5),
                inset 0 0 30px rgba(0, 255, 0, 0.1);
            padding: 40px;
        }

        h1 {
            color: #00ff00;
            font-size: 2.5em;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 0 0 10px #00ff00;
            border-bottom: 2px solid #00ff00;
            padding-bottom: 15px;
        }

        .content {
            line-height: 1.8;
            font-size: 1.1em;
            position: relative;
            z-index: 3;
        }

        .content p {
            margin-bottom: 20px;
            text-align: justify;
        }

        .content h2 {
            color: #00ff00;
            margin-top: 30px;
            margin-bottom: 15px;
            text-shadow: 0 0 5px #00ff00;
        }

        .content ul {
            margin-left: 30px;
            margin-bottom: 20px;
        }

        .content li {
            margin-bottom: 10px;
        }

        .theorem-box {
            background: rgba(0, 255, 0, 0.05);
            border: 2px solid #00ff00;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.2);
        }

        .nav-button {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            background: linear-gradient(135deg, #1a1a2e, #2a2a4e);
            border: 3px solid #00ff00;
            color: #00ff00;
            text-decoration: none;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
            transition: all 0.3s;
            text-align: center;
            text-shadow: 0 0 10px #00ff00;
            z-index: 10;
            width: 250px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .nav-button:hover {
            background: linear-gradient(135deg, #2a2a4e, #3a3a6e);
            box-shadow: 0 0 25px rgba(0, 255, 0, 0.8);
            transform: translateX(-50%) scale(1.05);
        }

        .nav-button.hit {
            animation: hitFlash 0.3s;
        }

        @keyframes hitFlash {
            0%, 100% { 
                background: linear-gradient(135deg, #1a1a2e, #2a2a4e);
                transform: translateX(-50%) scale(1);
            }
            50% { 
                background: linear-gradient(135deg, #ffff00, #ffaa00);
                transform: translateX(-50%) scale(1.2);
                box-shadow: 0 0 40px rgba(255, 255, 0, 1);
            }
        }

        .button-container {
            text-align: center;
            position: relative;
            margin-top: 40px;
            height: 100px;
        }

        .controls {
            display: none;
        }

        #ballCanvas {
            position: relative;
            width: 100%;
            max-width: 600px;
            height: 400px;
            margin: 20px auto;
            border: 2px solid #00ff00;
            background: rgba(10, 10, 26, 0.5);
            z-index: 3;
        }

        .visualization-section {
            margin: 40px 0 20px;
            padding: 30px;
            background: rgba(0, 255, 0, 0.04);
            border: 1px solid rgba(0, 255, 0, 0.25);
            border-radius: 8px;
        }

        .visualization-section h3 {
            margin-bottom: 12px;
            color: #00ff00;
            text-shadow: 0 0 4px rgba(0, 255, 0, 0.4);
        }

        .formula-box {
            background: rgba(0, 255, 0, 0.12);
            border-left: 4px solid #00ff00;
            padding: 18px;
            margin: 18px 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }

        .highlight {
            color: #ffee58;
        }

        .key-points {
            margin: 20px 0 10px;
            padding-left: 20px;
        }

        .key-points li {
            margin-bottom: 12px;
        }

        #vectorFieldCanvas {
            width: 100%;
            height: 420px;
            margin: 20px auto 10px;
            border: 2px solid rgba(0, 255, 0, 0.4);
            border-radius: 8px;
            background: radial-gradient(circle at center, rgba(0, 255, 0, 0.08), rgba(0, 0, 0, 0.9));
        }

        .viz-caption {
            font-size: 0.95em;
            color: rgba(204, 255, 204, 0.85);
            text-align: center;
            margin-top: 8px;
        }

        .info-panel {
            margin-top: 16px;
            padding: 14px 16px;
            background: rgba(6, 24, 20, 0.55);
            border: 1px solid rgba(0, 255, 204, 0.25);
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            color: rgba(230, 255, 241, 0.92);
            line-height: 1.5;
        }

        .info-panel strong {
            color: #ffee58;
        }

        .info-panel .vector {
            color: #4bf3c7;
        }

        .info-panel .note {
            display: block;
            margin-top: 6px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.85em;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .cursor {
            animation: blink 1s infinite;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>>> THE HAIRY BALL THEOREM <span class="cursor">_</span></h1>
        
        <div class="content">
            <h2>>> TL;DR</h2>
            <ul class="key-points">
                <li>Try to comb hair on a perfect sphere and one spot always sticks up: that’s the theorem.</li>
                <li>The surface is centered at the origin, so any tangent vector is measured from <strong>(0, 0, 0)</strong>.</li>
                <li>This happens on every even-dimensional sphere, so a zero vector is unavoidable.</li>
            </ul>

            <div class="theorem-box">
                <h2>>> FORMULA SNAPSHOT</h2>
                <p>
                    A concrete tangent field that makes the theorem visible is:
                </p>
                <div class="formula-box">
                    <code>F(x, y, z) = (-y, x, 0)</code>, for <code>(x, y, z) ∈ S²</code>
                </div>
                <p>
                    The dot product <code>F · (x, y, z) = 0</code> keeps the arrows tangent. At the poles,
                    where <code>x = y = 0</code>, the vector collapses to <code>0</code>—the unavoidable bald spot.
                </p>
                <p>
                    Because the sphere is centered at <strong>(0, 0, 0)</strong>, every surface point already
                    lies on the unit sphere. The formula uses the same coordinates, so the tangent vectors are
                    computed relative to that center without any offset.
                </p>
            </div>

            <div class="visualization-section">
                <h3>>> TURN THE SPHERE</h3>
                <p>
                    Explore the tangent flow generated by <code>F</code>. Notice how the vectors wrap around
                    but must fade out at the highlighted <span class="highlight">zero</span>.
                </p>
                <div id="vectorFieldCanvas"></div>
                <p class="viz-caption">
                    Drag to rotate · Yellow glow marks the forced zero vector.
                </p>
                <div id="vectorInfo" class="info-panel">
                    Click any arrow to inspect its coordinates <strong>(x, y, z)</strong> and the tangent field value <span class="vector">F(x, y, z)</span>.
                </div>
            </div>

            <h2>>> QUICK CONTEXT</h2>
            <ul class="key-points">
                <li><strong>Meteorology:</strong> Guarantees a lull point on Earth’s wind map at every instant.</li>
                <li><strong>Graphics & robotics:</strong> Frame fields on spherical meshes must account for singularities.</li>
                <li><strong>Topology:</strong> Shares DNA with Brouwer’s fixed-point theorem and Euler characteristic arguments.</li>
            </ul>
        </div>

        <div class="button-container">
            <a href="about-me.html" class="nav-button" id="homeBtn"><< BACK TO ABOUT ME</a>
        </div>
    </div>

    <script>
        window.addEventListener('DOMContentLoaded', () => {
            const container = document.getElementById('vectorFieldCanvas');
            if (!container) {
                return;
            }

            const canvas = document.createElement('canvas');
            canvas.style.display = 'block';
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.setAttribute('aria-label', 'Interactive tangent vector field on a sphere');
            canvas.setAttribute('role', 'img');
            container.innerHTML = '';
            container.appendChild(canvas);

            const infoPanel = document.getElementById('vectorInfo');
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;

            let width = 0;
            let height = 0;
            let radius = 0;
            const focus = 3.2;

            const createVector = (x, y, z) => ({ x, y, z });
            const normalize = (v) => {
                const len = Math.hypot(v.x, v.y, v.z);
                if (len < 1e-9) {
                    return null;
                }
                return { x: v.x / len, y: v.y / len, z: v.z / len };
            };

            let rotX = 0.4;
            let rotY = -0.8;

            const pointGrid = [];
            const zeroEntries = [];

            const addSample = (pos) => {
                const tangent = createVector(-pos.y, pos.x, 0);
                const tangentUnit = normalize(tangent);
                if (!tangentUnit) {
                    zeroEntries.push({ pos });
                    return;
                }
                pointGrid.push({ pos, tangent: tangentUnit });
            };

            const baseLatitudes = [];
            for (let phi = -75; phi <= 75; phi += 15) {
                baseLatitudes.push(phi);
            }
            const polarLatitudes = [83, 87, -83, -87];
            const latitudes = [...baseLatitudes, ...polarLatitudes];

            latitudes.forEach((phiDeg) => {
                const phi = (Math.PI / 180) * phiDeg;
                const cosPhi = Math.cos(phi);
                const steps = Math.max(14, Math.round(28 * Math.abs(cosPhi)) + 12);
                for (let i = 0; i < steps; i++) {
                    const theta = (Math.PI * 2 * i) / steps;
                    const x = cosPhi * Math.cos(theta);
                    const y = Math.sin(phi);
                    const z = cosPhi * Math.sin(theta);
                    addSample(createVector(x, y, z));
                }
            });

            const polarRadii = [0.18, 0.28, 0.38];
            const polarSteps = 36;
            polarRadii.forEach((r) => {
                for (let i = 0; i < polarSteps; i++) {
                    const theta = (Math.PI * 2 * i) / polarSteps;
                    const x = r * Math.cos(theta);
                    const y = r * Math.sin(theta);
                    const xySq = x * x + y * y;
                    if (xySq >= 1) {
                        continue;
                    }
                    const z = Math.sqrt(1 - xySq);
                    addSample(createVector(x, y, z));
                }
            });

            const zeroPole = createVector(0, 0, 1);

            const rotateVector = (v) => {
                const cosY = Math.cos(rotY);
                const sinY = Math.sin(rotY);
                const cosX = Math.cos(rotX);
                const sinX = Math.sin(rotX);

                const x1 = v.x * cosY + v.z * sinY;
                const z1 = -v.x * sinY + v.z * cosY;
                const y2 = v.y * cosX - z1 * sinX;
                const z2 = v.y * sinX + z1 * cosX;
                return createVector(x1, y2, z2);
            };

            const project = (v) => {
                const depth = focus - v.z;
                if (depth <= 0.1) {
                    return null;
                }
                const scale = (radius * focus) / depth;
                return {
                    x: width / 2 + v.x * scale,
                    y: height / 2 - v.y * scale,
                    scale,
                    depth
                };
            };

            const resize = () => {
                width = container.clientWidth || 640;
                height = container.clientHeight || 420;
                canvas.width = width * dpr;
                canvas.height = height * dpr;
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                radius = Math.min(width, height) / 2.2;
            };

            const drawSphere = () => {
                const cx = width / 2;
                const cy = height / 2;
                const highlightX = cx - radius * 0.35;
                const highlightY = cy - radius * 0.55;
                const gradient = ctx.createRadialGradient(highlightX, highlightY, radius * 0.18, cx, cy, radius);
                gradient.addColorStop(0, 'rgba(34, 255, 204, 0.42)');
                gradient.addColorStop(0.5, 'rgba(10, 90, 75, 0.82)');
                gradient.addColorStop(1, 'rgba(4, 20, 24, 0.94)');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = 'rgba(0, 255, 200, 0.18)';
                ctx.lineWidth = 1.1;
                ctx.beginPath();
                const ringSteps = 96;
                for (let i = 0; i <= ringSteps; i++) {
                    const theta = (Math.PI * 2 * i) / ringSteps;
                    const point = rotateVector(createVector(Math.cos(theta), 0, Math.sin(theta)));
                    if (point.z < 0) {
                        continue;
                    }
                    const projected = project(point);
                    if (!projected) {
                    continue;
                }
                    if (i === 0) {
                        ctx.moveTo(projected.x, projected.y);
                    } else {
                        ctx.lineTo(projected.x, projected.y);
                    }
                }
                ctx.stroke();
            };

            const drawArrow = (sample) => {
                const rotatedPos = rotateVector(sample.pos);
                if (rotatedPos.z < -0.12) {
                    return;
                }

                const start = project(rotatedPos);
                if (!start) {
                    return;
                }

                const rotatedField = rotateVector(sample.tangent);
                const arrowScale = 0.26;
                const end3D = createVector(
                    rotatedPos.x + rotatedField.x * arrowScale,
                    rotatedPos.y + rotatedField.y * arrowScale,
                    rotatedPos.z + rotatedField.z * arrowScale
                );

                const end = project(end3D);
                if (!end) {
                    return;
                }

                ctx.strokeStyle = 'rgba(120, 255, 220, 0.55)';
                ctx.lineWidth = 1.6;
                ctx.beginPath();
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
            ctx.stroke();

                const dx = end.x - start.x;
                const dy = end.y - start.y;
                const baseAngle = Math.atan2(dy, dx);
                const arrowLength = Math.hypot(dx, dy);
                const headLength = Math.min(arrowLength * 0.32, 10);

                ctx.fillStyle = 'rgba(120, 255, 220, 0.6)';
                ctx.beginPath();
                ctx.moveTo(end.x, end.y);
                ctx.lineTo(
                    end.x - headLength * Math.cos(baseAngle - Math.PI / 6),
                    end.y - headLength * Math.sin(baseAngle - Math.PI / 6)
                );
                ctx.lineTo(
                    end.x - headLength * Math.cos(baseAngle + Math.PI / 6),
                    end.y - headLength * Math.sin(baseAngle + Math.PI / 6)
                );
                ctx.closePath();
                ctx.fill();
            };

            const drawZeroMarker = () => {
                const rotated = rotateVector(zeroPole);
                const projected = project(rotated);
                if (!projected || rotated.z < -0.05) {
                    return;
                }

                const glowRadius = Math.max(6, radius * 0.075);
                ctx.save();
                ctx.shadowColor = 'rgba(255, 255, 140, 0.95)';
                ctx.shadowBlur = glowRadius * 0.9;
                ctx.fillStyle = 'rgba(255, 255, 170, 0.92)';
                ctx.beginPath();
                ctx.arc(projected.x, projected.y, glowRadius * 0.55, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                ctx.strokeStyle = 'rgba(255, 255, 150, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(projected.x, projected.y, glowRadius, 0, Math.PI * 2);
                ctx.stroke();
            };

            let selectedPoint = null;

            const drawSelection = () => {
                if (!selectedPoint) {
                    return;
                }
                const rotated = rotateVector(selectedPoint.pos);
                const projected = project(rotated);
                if (!projected) {
                    return;
                }
                const markerRadius = Math.max(5, projected.scale * 0.05);
                ctx.strokeStyle = 'rgba(255, 205, 95, 0.9)';
                ctx.lineWidth = 2.2;
                ctx.beginPath();
                ctx.arc(projected.x, projected.y, markerRadius, 0, Math.PI * 2);
                ctx.stroke();
            };

            const draw = () => {
                ctx.clearRect(0, 0, width, height);
                drawSphere();
                pointGrid.forEach(drawArrow);
                drawZeroMarker();
                drawSelection();
            };

            const formatNumber = (value) => {
                const rounded = Math.abs(value) < 1e-4 ? 0 : value;
                const text = rounded.toFixed(3);
                return text === '-0.000' ? '0.000' : text;
            };

            const updateInfo = (pos) => {
                if (!infoPanel) {
                    return;
                }
                if (!pos) {
                    infoPanel.textContent = 'Click any arrow to inspect its coordinates (x, y, z) and the tangent field value F(x, y, z).';
                    return;
                }

                const field = createVector(-pos.y, pos.x, 0);
                const magnitude = Math.hypot(field.x, field.y, field.z);
                const parts = [
                    `<strong>p</strong> = (${formatNumber(pos.x)}, ${formatNumber(pos.y)}, ${formatNumber(pos.z)})`,
                    `<span class="vector"><strong>F(p)</strong> = (-y, x, 0) = (${formatNumber(field.x)}, ${formatNumber(field.y)}, ${formatNumber(field.z)})</span>`
                ];

                if (magnitude < 1e-3) {
                    parts.push('<span class="note">F(p) = 0 – the tangent field vanishes here.</span>');
                } else {
                    parts.push(`<span class="note">‖F(p)‖ = ${formatNumber(magnitude)}</span>`);
                }

                infoPanel.innerHTML = parts.join('<br>');
            };

            const candidatePoints = () => {
                return [
                    ...pointGrid,
                    ...zeroEntries,
                    { pos: zeroPole }
                ];
            };

            const sampleAt = (clientX, clientY) => {
                const rect = canvas.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;

                let closest = null;
                let minDist = Infinity;

                candidatePoints().forEach((candidate) => {
                    const projected = project(rotateVector(candidate.pos));
                    if (!projected) {
                        return;
                    }
                    const dx = projected.x - x;
                    const dy = projected.y - y;
                    const distance = Math.hypot(dx, dy);
                    if (distance < minDist) {
                        minDist = distance;
                        closest = candidate;
                    }
                });

                if (!closest) {
                    return;
                }
                selectedPoint = closest;
                updateInfo(closest.pos);
            };

            let pointerActive = false;
            let lastPointerX = 0;
            let lastPointerY = 0;

            const clamp = (value, min, max) => Math.max(min, Math.min(max, value));

            const onPointerDown = (event) => {
                pointerActive = true;
                lastPointerX = event.clientX;
                lastPointerY = event.clientY;
                if (canvas.setPointerCapture) {
                    try {
                        canvas.setPointerCapture(event.pointerId);
                    } catch (err) {
                        /* ignore */
                    }
                }
            };

            const onPointerMove = (event) => {
                if (!pointerActive) {
                    return;
                }
                const sensitivity = 0.003;
                const dx = event.clientX - lastPointerX;
                const dy = event.clientY - lastPointerY;
                rotY += dx * sensitivity;
                rotX = clamp(rotX + dy * sensitivity, -Math.PI / 2 + 0.15, Math.PI / 2 - 0.15);
                lastPointerX = event.clientX;
                lastPointerY = event.clientY;
            };

            const endPointerInteraction = (event) => {
                pointerActive = false;
                if (canvas.hasPointerCapture && canvas.hasPointerCapture(event.pointerId)) {
                    canvas.releasePointerCapture(event.pointerId);
                }
            };

            canvas.addEventListener('pointerdown', onPointerDown);
            canvas.addEventListener('pointermove', onPointerMove);
            canvas.addEventListener('pointerup', (event) => {
                endPointerInteraction(event);
            });
            canvas.addEventListener('pointercancel', (event) => {
                endPointerInteraction(event);
            });
            canvas.addEventListener('pointerleave', () => {
                pointerActive = false;
            });
            canvas.addEventListener('contextmenu', (event) => event.preventDefault());
            canvas.addEventListener('click', (event) => {
                sampleAt(event.clientX, event.clientY);
            });

            const observer = window.ResizeObserver ? new ResizeObserver(resize) : null;
            if (observer) {
                observer.observe(container);
            }
            window.addEventListener('resize', resize);

            resize();
            updateInfo(null);

            const animate = () => {
            draw();
                requestAnimationFrame(animate);
            };

            animate();
        });
    </script>
    <script src="navigation-toggle.js"></script>
</body>
</html>
