<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SECRET GAME - Triangle Defense</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
            color: #00ff00;
        }

        /* Game-like border effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 8px solid #ff0000;
            box-shadow: 
                0 0 20px #ff0000,
                inset 0 0 20px rgba(255, 0, 0, 0.1);
            pointer-events: none;
            z-index: 1;
        }

        /* Corner decorations */
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                linear-gradient(90deg, #ff0000 2px, transparent 2px),
                linear-gradient(180deg, #ff0000 2px, transparent 2px);
            background-size: 40px 40px;
            opacity: 0.1;
            pointer-events: none;
            z-index: 0;
        }

        .game-container {
            position: relative;
            z-index: 2;
            width: 1400px;
            height: 900px;
            background: #1a1a2e;
            border: 4px solid #ff0000;
            box-shadow: 
                0 0 30px rgba(255, 0, 0, 0.5),
                inset 0 0 30px rgba(255, 0, 0, 0.1);
            padding: 20px;
        }

        h1 {
            color: #ff0000;
            font-size: 2em;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #ff0000;
        }

        .subtitle {
            color: #ff0000;
            text-align: center;
            margin-bottom: 15px;
            opacity: 0.8;
            font-size: 0.9em;
        }

        #gameCanvas {
            border: 2px solid #ff0000;
            background: #0a0a1a;
            display: block;
            margin: 0 auto;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);
            cursor: crosshair;
            pointer-events: auto;
        }

        .upgrade-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
        }

        .upgrade-btn {
            padding: 8px 15px;
            background: linear-gradient(135deg, #1a1a2e, #2a2a4e);
            border: 2px solid #00ff00;
            color: #00ff00;
            font-size: 0.9em;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 5px #00ff00;
            border-radius: 5px;
        }

        .upgrade-btn:hover {
            background: linear-gradient(135deg, #2a2a4e, #3a3a6e);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.8);
            transform: scale(1.05);
        }

        .upgrade-selection {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 4px solid #ff0000;
            border-radius: 10px;
            padding: 30px;
            display: none;
            z-index: 1000;
            box-shadow: 0 0 50px rgba(255, 0, 0, 0.8);
            min-width: 600px;
            text-align: center;
        }

        .upgrade-selection h2 {
            color: #ff0000;
            font-size: 2em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff0000;
        }

        .upgrade-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .upgrade-option {
            padding: 15px;
            border: 3px solid;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            background: rgba(26, 26, 46, 0.8);
        }

        .upgrade-option:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px currentColor;
        }

        .upgrade-option.common {
            border-color: #808080;
            color: #808080;
        }

        .upgrade-option.uncommon {
            border-color: #00ff00;
            color: #00ff00;
        }

        .upgrade-option.rare {
            border-color: #0080ff;
            color: #0080ff;
        }

        .upgrade-option.legendary {
            border-color: #ff8000;
            color: #ff8000;
        }

        .upgrade-option h3 {
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .upgrade-option p {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .barrier {
            position: absolute;
            width: 100px;
            height: 10px;
            background: rgba(0, 255, 255, 0.5);
            border: 2px solid #00ffff;
            border-radius: 5px;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
            color: #ff0000;
            font-size: 1.1em;
            font-weight: bold;
        }

        .stat-item {
            padding: 8px 15px;
            background: rgba(255, 0, 0, 0.1);
            border: 2px solid #ff0000;
            border-radius: 5px;
            min-width: 150px;
            text-align: center;
        }

        .controls {
            text-align: center;
            color: #ff0000;
            margin-top: 10px;
            font-size: 0.85em;
        }

        .autoshoot-toggle {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1000;
            padding: 8px 15px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff0000;
            color: #ff0000;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            cursor: pointer;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }

        .autoshoot-toggle:hover {
            background: rgba(255, 0, 0, 0.2);
        }

        .autoshoot-toggle.active {
            border-color: #00ff00;
            color: #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border: 4px solid #ff0000;
            border-radius: 10px;
            color: #ff0000;
            text-align: center;
            display: none;
            z-index: 1000;
            box-shadow: 0 0 50px rgba(255, 0, 0, 0.8);
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            pointer-events: auto;
        }

        .game-over h2 {
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff0000;
        }

        .game-over .name-input-section {
            margin: 20px 0;
            pointer-events: auto;
            position: relative;
            z-index: 1001;
        }

        .game-over input[type="text"] {
            padding: 10px 15px;
            font-size: 1.1em;
            background: rgba(26, 26, 46, 0.8);
            border: 2px solid #ff0000;
            color: #ff0000;
            font-family: 'Courier New', monospace;
            border-radius: 5px;
            width: 250px;
            text-align: center;
            pointer-events: auto;
            position: relative;
            z-index: 1002;
        }

        .game-over input[type="text"]:focus {
            outline: none;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }

        .game-over .save-score-btn {
            margin-top: 10px;
            padding: 10px 20px;
            background: linear-gradient(135deg, #00ff00, #00aa00);
            color: #000;
            border: 2px solid #00ff00;
            font-weight: bold;
        }

        .game-over .save-score-btn:hover {
            background: linear-gradient(135deg, #00aa00, #00ff00);
        }

        .game-over .leaderboard {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid rgba(255, 0, 0, 0.3);
        }

        .game-over .leaderboard h3 {
            font-size: 1.5em;
            margin-bottom: 15px;
            text-shadow: 0 0 10px #ff0000;
        }

        .game-over .leaderboard-list {
            list-style: none;
            padding: 0;
            margin: 0;
            text-align: left;
        }

        .game-over .leaderboard-item {
            padding: 10px;
            margin: 5px 0;
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid rgba(255, 0, 0, 0.3);
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            font-size: 1.1em;
        }

        .game-over .leaderboard-item .rank {
            font-weight: bold;
            margin-right: 10px;
            min-width: 30px;
        }

        .game-over .leaderboard-item .name {
            flex: 1;
            text-align: left;
        }

        .game-over .leaderboard-item .score {
            font-weight: bold;
            color: #ffff00;
        }

        .game-over .loading {
            color: rgba(255, 0, 0, 0.6);
            font-style: italic;
        }

        .game-over button {
            background: linear-gradient(135deg, #ff0000, #aa0000);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
            margin-right: 10px;
            transition: transform 0.2s;
            font-family: 'Courier New', monospace;
        }

        .game-over button:hover {
            transform: scale(1.05);
        }

        .nav-button {
            background: linear-gradient(135deg, #ff0000, #aa0000);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>‚ö† SECRET GAME ‚ö†</h1>
        <div class="subtitle">>> TRIANGLE DEFENSE - SURVIVE AS LONG AS POSSIBLE <<</div>
        
        <canvas id="gameCanvas" width="1360" height="700"></canvas>
        
        <div class="stats">
            <div class="stat-item">Score: <span id="score">0</span></div>
            <div class="stat-item">Wave: <span id="wave">1</span></div>
            <div class="stat-item">Enemies: <span id="enemiesRemaining">0</span> / <span id="totalEnemies">0</span></div>
            <div class="stat-item">Time: <span id="time">0</span>s</div>
        </div>
        
        <button id="autoshootToggle" class="autoshoot-toggle" title="Toggle Auto-Shoot (Hold Space)">üî´ Auto-Shoot: OFF</button>

        <div class="controls">
            <p>Use Mouse to Rotate | Click or Space to Shoot | WASD to Move | ESC to Exit</p>
        </div>
    </div>

    <div class="upgrade-selection" id="upgradeSelection">
        <h2>WAVE COMPLETE!</h2>
        <p style="color: #ff0000; margin-bottom: 20px;">Choose an Upgrade:</p>
        <div class="upgrade-options" id="upgradeOptions">
            <!-- Upgrade options will be generated here -->
        </div>
    </div>

    <div class="game-over" id="gameOver">
        <h2>GAME OVER!</h2>
        <p>Final Score: <span id="finalScore">0</span></p>
        <p>Time Survived: <span id="finalTime">0</span>s</p>
        <p>Waves Completed: <span id="finalWave">0</span></p>
        
        <div class="name-input-section" id="nameInputSection">
            <p>Enter your name to save your score:</p>
            <input type="text" id="playerName" placeholder="Your Name" maxlength="20" autocomplete="off">
            <br>
            <button class="save-score-btn" id="saveScoreBtn" onclick="saveScore()">Save Score</button>
        </div>

        <div class="leaderboard" id="leaderboard">
            <h3>üèÜ LEADERBOARD üèÜ</h3>
            <ul class="leaderboard-list" id="leaderboardList">
                <li class="loading">Loading leaderboard...</li>
            </ul>
        </div>

        <button onclick="resetGame()">Play Again</button>
        <button onclick="window.location.href='index.html'" class="nav-button">Back to Home</button>
    </div>

    <script type="module">
        import { firebaseConfig } from './firebase-config.js';
        
        // Initialize Firebase
        let db = null;
        let scoresCollection = null;
        
        (async () => {
            try {
                const [{ initializeApp }, { getFirestore, collection, addDoc, query, orderBy, limit, onSnapshot, serverTimestamp }] = await Promise.all([
                    import('https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js'),
                    import('https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js')
                ]);
                
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                scoresCollection = collection(db, 'game_scores');
                
                // Make functions globally available
                window.saveScore = async function() {
                    const nameInput = document.getElementById('playerName');
                    if (!nameInput) {
                        alert('Name input not found. Please refresh the page.');
                        return;
                    }
                    
                    const name = (nameInput.value || '').trim();
                    
                    if (!name) {
                        alert('Please enter your name!');
                        nameInput.focus();
                        return;
                    }
                    
                    if (!scoresCollection) {
                        alert('Firebase not initialized. Please refresh the page.');
                        return;
                    }
                    
                    // Get score values from DOM
                    const finalScore = parseInt(document.getElementById('finalScore').textContent) || 0;
                    const finalWave = parseInt(document.getElementById('finalWave').textContent) || 0;
                    const finalTime = parseInt(document.getElementById('finalTime').textContent) || 0;
                    
                    const saveBtn = document.getElementById('saveScoreBtn');
                    saveBtn.disabled = true;
                    saveBtn.textContent = 'Saving...';
                    
                    try {
                        await addDoc(scoresCollection, {
                            name: name,
                            score: finalScore,
                            wave: finalWave,
                            time: finalTime,
                            timestamp: serverTimestamp()
                        });
                        
                        nameInput.disabled = true;
                        saveBtn.textContent = 'Score Saved!';
                        saveBtn.style.background = 'linear-gradient(135deg, #00aa00, #00ff00)';
                        
                        // Reload leaderboard
                        if (typeof loadLeaderboard === 'function') {
                            loadLeaderboard();
                        }
                    } catch (error) {
                        console.error('Error saving score:', error);
                        alert('Failed to save score: ' + error.message);
                        saveBtn.disabled = false;
                        saveBtn.textContent = 'Save Score';
                    }
                };
                
                window.loadLeaderboard = function() {
                    if (!scoresCollection) {
                        document.getElementById('leaderboardList').innerHTML = '<li class="loading">Firebase not initialized</li>';
                        return;
                    }
                    
                    const leaderboardList = document.getElementById('leaderboardList');
                    leaderboardList.innerHTML = '<li class="loading">Loading leaderboard...</li>';
                    
                    const q = query(scoresCollection, orderBy('score', 'desc'), limit(10));
                    
                    onSnapshot(q, (snapshot) => {
                        if (snapshot.empty) {
                            leaderboardList.innerHTML = '<li class="loading">No scores yet. Be the first!</li>';
                            return;
                        }
                        
                        leaderboardList.innerHTML = '';
                        snapshot.forEach((doc, index) => {
                            const data = doc.data();
                            const li = document.createElement('li');
                            li.className = 'leaderboard-item';
                            li.innerHTML = `
                                <span class="rank">#${index + 1}</span>
                                <span class="name">${data.name || 'Anonymous'}</span>
                                <span class="score">${data.score || 0}</span>
                            `;
                            leaderboardList.appendChild(li);
                        });
                    }, (error) => {
                        console.error('Error loading leaderboard:', error);
                        leaderboardList.innerHTML = '<li class="loading">Failed to load leaderboard</li>';
                    });
                };
            } catch (error) {
                console.error('Firebase initialization error:', error);
                // Continue game without Firebase
            }
        })();
    </script>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let score = 0;
        let wave = 1;
        let gameTime = 0;
        let gameRunning = true;
        let wavePaused = false;
        let barrierMessageShown = false; // Track if barrier message has been shown
        let gameStartTime = Date.now();
        let lastEnemySpawn = Date.now();
        let lastShotTime = Date.now();
        let lastHealTime = Date.now();
        let spacePressed = false;
        let isContinuouslyShooting = false; // Tracks if autoshoot is actively shooting
        let inputModeActive = false; // Flag to disable all game keyboard handlers when input is active
        let enemySpawnRate = 1500; // milliseconds
        
        // Autoshoot toggle (cookie-based)
        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
        }
        
        function setCookie(name, value, days) {
            const expires = new Date();
            expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
            document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/`;
        }
        
        let autoshootEnabled = getCookie('autoshoot') === 'true';
        
        // Setup autoshoot toggle button
        const autoshootToggle = document.getElementById('autoshootToggle');
        if (autoshootToggle) {
            autoshootToggle.addEventListener('click', () => {
                autoshootEnabled = !autoshootEnabled;
                setCookie('autoshoot', autoshootEnabled.toString(), 365);
                updateAutoshootButton();
            });
            
            function updateAutoshootButton() {
                if (autoshootEnabled) {
                    autoshootToggle.textContent = 'üî´ Auto-Shoot: ON';
                    autoshootToggle.classList.add('active');
                } else {
                    autoshootToggle.textContent = 'üî´ Auto-Shoot: OFF';
                    autoshootToggle.classList.remove('active');
                }
            }
            
            updateAutoshootButton();
        }
        let enemiesPerWave = 5;
        let enemiesSpawned = 0;
        let enemiesRemaining = 5; // Track remaining enemies for counter
        let waveCompleted = false;

        // Player (triangle)
        const player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            angle: 0,
            size: 25,
            speed: 0.05,
            moveSpeed: 5,
            color: '#00ff00',
            health: 3,
            maxHealth: 3,
            fireRate: 500, // milliseconds between shots (nerfed)
            damage: 1,
            // Upgrade abilities
            shotMode: 'single', // single, double, triple, quad
            healOverTime: false,
            barriers: 0, // Number of barriers available
            maxBarriers: 0,
            fasterBullets: false,
            barrierPerRound: false,
            bulletSizeLevel: 0,
            timeSlowLevel: 0,
            luckLevel: 0,
            armorLevel: 0,
            pierceLevel: 0,
            critChanceLevel: 0,
            vampirismLevel: 0,
            explosiveLevel: 0
        };

        // Bullets array
        const bullets = [];

        // Enemies array
        const enemies = [];

        // Particles array for effects
        const particles = [];

        // Barriers
        const barriers = [];
        const BARRIER_CONFIG = {
            width: 140,
            height: 16,
            maxLife: 12
        };

        // Mouse position
        let mouseX = canvas.width / 2;
        let mouseY = canvas.height / 2;

        // Keyboard state
        const keys = {};

        // Enemy types
        const ENEMY_TYPES = {
            NORMAL: 'normal',
            ZIGZAG: 'zigzag',
            JUMPER: 'jumper'
        };

        // Make sure canvas can receive events
        canvas.setAttribute('tabindex', '0');
        canvas.style.outline = 'none';
        
        // Event listeners
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        canvas.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            canvas.focus(); // Focus on click
            if (gameRunning && !wavePaused) {
                const upgradeMenu = document.getElementById('upgradeSelection');
                if (!upgradeMenu || upgradeMenu.style.display !== 'block') {
                    shoot();
                }
            }
        });
        
        // Aggressive focus management
        canvas.focus();
        window.addEventListener('load', () => {
            canvas.focus();
            setTimeout(() => canvas.focus(), 100);
        });
        canvas.addEventListener('mousedown', (e) => {
            canvas.focus();
            e.preventDefault();
        }, true);
        canvas.addEventListener('mouseenter', () => canvas.focus());
        
        // Auto-focus canvas when any key is pressed (but not when input is active)
        document.addEventListener('keydown', () => {
            if (inputModeActive) {
                return; // Don't steal focus from input
            }
            if (document.activeElement !== canvas && document.activeElement !== document.body) {
                canvas.focus();
            }
        }, true);

        // ABSOLUTE SIMPLEST - NO CHECKS, JUST SHOOT
        function fireBullet() {
            // Check fire rate - respect the nerfed fire rate
            const now = Date.now();
            const minFireRate = player?.fireRate || 500;
            if (now - lastShotTime < minFireRate) return; // Respect full fire rate
            lastShotTime = now;
            
            // Get player position - use defaults if missing
            const px = player?.x ?? canvas.width/2;
            const py = player?.y ?? canvas.height/2;
            const pangle = player?.angle ?? 0;
            
            // Get bullet speed
            let bulletSpeed = 12;
            if (player?.fasterBullets) {
                if (player.bulletSpeedLevel === 1) bulletSpeed = 15;
                else if (player.bulletSpeedLevel === 2) bulletSpeed = 18;
                else bulletSpeed = 21;
            }
            
            // Get shot angles based on mode
            let angles = [0];
            const mode = player?.shotMode ?? 'single';
            if (mode === 'double') angles = [-0.15, 0.15];
            else if (mode === 'triple') angles = [-0.2, 0, 0.2];
            else if (mode === 'quad') angles = [-0.25, -0.1, 0.1, 0.25];
            
            // Calculate bullet size multiplier from upgrade
            let sizeMultiplier = 0;
            if (player?.bulletSizeLevel) {
                sizeMultiplier = player.bulletSizeLevel * 0.5; // 0.5x, 1x, 1.5x
            }
            
            // Create bullets - no checks, just create them
            angles.forEach(offset => {
                let bulletDamage = player?.damage ?? 1;
                
                // Apply crit chance
                if (player?.critChanceLevel && Math.random() < (player.critChanceLevel * 0.1)) {
                    bulletDamage *= 2;
                }
                
                // Apply bullet size damage bonus
                if (sizeMultiplier > 0) {
                    bulletDamage *= (1 + sizeMultiplier * 0.3); // 30% damage per size level
                }
                
                bullets.push({
                    x: px,
                    y: py,
                    angle: pangle + offset,
                    speed: bulletSpeed,
                    radius: 5,
                    color: '#ffff00',
                    damage: bulletDamage,
                    sizeMultiplier: sizeMultiplier,
                    pierceCount: player?.pierceLevel || 0,
                    explosiveLevel: player?.explosiveLevel || 0
                });
            });
        }
        
        // Helper to check if input is focused
        const isInputFocused = function() {
            const active = document.activeElement;
            if (!active) return false;
            const tagName = active.tagName ? active.tagName.toUpperCase() : '';
            return tagName === 'INPUT' || tagName === 'TEXTAREA' || active.id === 'playerName' || active.isContentEditable;
        };
        
        // DIRECT SPACE KEY HANDLER - NO CONDITIONS, JUST SHOOT
        const handleSpaceKey = function(e) {
            // CRITICAL: If input mode is active, DO NOTHING - let input handle everything
            if (inputModeActive) {
                return true; // Allow default behavior
            }
            
            // CRITICAL: Check target FIRST in capture phase - before preventing default
            const target = e.target || e.srcElement;
            if (target) {
                const tagName = target.tagName ? target.tagName.toUpperCase() : '';
                if (tagName === 'INPUT' || tagName === 'TEXTAREA' || target.id === 'playerName') {
                    return true; // Let input handle it - don't interfere at all
                }
            }
            
            // Also check active element
            const active = document.activeElement;
            if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.id === 'playerName')) {
                return true; // Let input handle it - don't interfere at all
            }
            
            // Only handle space key if not in input
            if (e.key === ' ' || e.code === 'Space' || e.keyCode === 32) {
                e.preventDefault();
                e.stopPropagation();
                
                if (autoshootEnabled) {
                    // When autoshoot is ON, toggle continuous shooting
                    isContinuouslyShooting = !isContinuouslyShooting;
                    // Fire immediately on toggle
                    fireBullet();
                } else {
                    // When autoshoot is OFF, just fire once
                    spacePressed = true;
                    fireBullet();
                }
                return false;
            }
            return true;
        };
        
        // Attach handlers - use capture phase but check input first
        window.addEventListener('keydown', handleSpaceKey, true);
        document.addEventListener('keydown', handleSpaceKey, true);
        canvas.addEventListener('keydown', handleSpaceKey, true);
        
        // Also as direct property handlers - but check for input first
        window.onkeydown = function(e) {
            if (inputModeActive || isInputFocused()) {
                return true; // Let input handle it
            }
            return handleSpaceKey(e);
        };
        document.onkeydown = function(e) {
            if (inputModeActive || isInputFocused()) {
                return true; // Let input handle it
            }
            return handleSpaceKey(e);
        };
        canvas.onkeydown = function(e) {
            if (inputModeActive || isInputFocused()) {
                return true; // Let input handle it
            }
            return handleSpaceKey(e);
        };
        
        // Backup handler
        const backupKeydownHandler = (e) => {
            // CRITICAL: If input mode is active, DO NOTHING except Escape
            if (inputModeActive) {
                if (e.key === 'Escape') {
                    if (confirm('Leave the game and return to home?')) {
                        window.location.href = 'index.html';
                    }
                }
                return; // Let input handle ALL other keys
            }
            
            // CRITICAL: Check if input is focused FIRST - don't interfere at all
            const active = document.activeElement;
            const target = e.target || e.srcElement;
            
            // Check if active element is an input
            if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.id === 'playerName')) {
                // Only handle Escape key when in input
                if (e.key === 'Escape') {
                    if (confirm('Leave the game and return to home?')) {
                        window.location.href = 'index.html';
                    }
                    return;
                }
                return; // Let input handle ALL other keys - don't prevent default, don't do anything
            }
            
            // Check if target is an input
            if (target && (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.id === 'playerName')) {
                return; // Let input handle it
            }
            
            // Handle space FIRST - before anything else
            if (e.key === ' ' || e.code === 'Space' || e.keyCode === 32) {
                e.preventDefault();
                e.stopPropagation();
                
                if (autoshootEnabled) {
                    // When autoshoot is ON, toggle continuous shooting
                    isContinuouslyShooting = !isContinuouslyShooting;
                    // Fire immediately on toggle
                    fireBullet();
                } else {
                    // When autoshoot is OFF, just fire once
                    spacePressed = true;
                    fireBullet();
                }
                
                return false;
            }
            
            const key = e.key.toLowerCase();
            keys[key] = true;
            
            // Handle Escape key to exit game
            if (e.key === 'Escape') {
                if (confirm('Leave the game and return to home?')) {
                    window.location.href = 'index.html';
                }
                keys[key] = false;
                return;
            }
            
            // Place barrier with 'B' key
            if (e.key.toLowerCase() === 'b' && gameRunning && !wavePaused && player.barriers > 0) {
                e.preventDefault();
                placeBarrier();
            }
            if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
                e.preventDefault();
            }
            // Prevent default for WASD keys
            if (['w', 'a', 's', 'd'].includes(key)) {
                e.preventDefault();
            }
        };
        document.addEventListener('keydown', backupKeydownHandler);

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            keys[key] = false;
            
            if (e.key === ' ' || e.code === 'Space' || e.keyCode === 32) {
                // Only reset spacePressed if autoshoot is disabled
                // If autoshoot is enabled, we use isContinuouslyShooting toggle instead
                if (!autoshootEnabled) {
                    spacePressed = false;
                }
            }
        });

        // Shoot function - simplified, always try to shoot
        function shoot() {
            // Only block if upgrade menu is definitely open
            const upgradeMenu = document.getElementById('upgradeSelection');
            if (upgradeMenu && upgradeMenu.style.display === 'block') {
                return; // Upgrade menu is open
            }
            
            // Only block if game is actually over
            if (!gameRunning) {
                return;
            }
            
            // Check fire rate - but be more lenient
            const now = Date.now();
            if (now - lastShotTime < Math.max(50, player.fireRate)) {
                return; // Too soon to shoot (minimum 50ms)
            }
            
            lastShotTime = now;
            
            let bulletSpeed = 12;
            if (player.fasterBullets) {
                if (player.bulletSpeedLevel === 1) {
                    bulletSpeed = 15; // 25% faster
                } else if (player.bulletSpeedLevel === 2) {
                    bulletSpeed = 18; // 50% faster
                } else {
                    bulletSpeed = 21; // 75% faster
                }
            }
            const angles = [];
            
            switch(player.shotMode) {
                case 'single':
                    angles = [0];
                    break;
                case 'double':
                    angles = [-0.15, 0.15];
                    break;
                case 'triple':
                    angles = [-0.2, 0, 0.2];
                    break;
                case 'quad':
                    angles = [-0.25, -0.1, 0.1, 0.25];
                    break;
            }
            
            angles.forEach(offset => {
                bullets.push({
                    x: player.x,
                    y: player.y,
                    angle: player.angle + offset,
                    speed: bulletSpeed,
                    radius: 5,
                    color: '#ffff00',
                    damage: player.damage
                });
            });
        }

        // Place barrier
        function placeBarrier() {
            if (!player || player.barriers <= 0) return;
            if (!BARRIER_CONFIG) return;

            const halfWidth = BARRIER_CONFIG.width / 2;
            const halfHeight = BARRIER_CONFIG.height / 2;

            // Ensure mouseX and mouseY are valid
            const currentMouseX = (typeof mouseX === 'number' && !isNaN(mouseX)) ? mouseX : canvas.width / 2;
            const currentMouseY = (typeof mouseY === 'number' && !isNaN(mouseY)) ? mouseY : canvas.height / 2;

            const clampedX = Math.min(
                canvas.width - halfWidth - 10,
                Math.max(halfWidth + 10, currentMouseX)
            );
            const clampedY = Math.min(
                canvas.height - halfHeight - 10,
                Math.max(halfHeight + 10, currentMouseY)
            );

            const dx = clampedX - player.x;
            const dy = clampedY - player.y;
            const angleToCursor = Math.atan2(dy, dx);
            const barrierAngle = angleToCursor + Math.PI / 2;

            barriers.push({
                x: clampedX,
                y: clampedY,
                width: BARRIER_CONFIG.width,
                height: BARRIER_CONFIG.height,
                angle: barrierAngle,
                life: BARRIER_CONFIG.maxLife,
                maxLife: BARRIER_CONFIG.maxLife,
                lastHitAt: 0
            });

            player.barriers--;
        }

        // Create enemy
        function spawnEnemy() {
            if (!gameRunning) return;
            
            // Spawn enemy from edge of canvas
            const side = Math.floor(Math.random() * 4);
            let x, y;

            switch(side) {
                case 0: // top
                    x = Math.random() * canvas.width;
                    y = -30;
                    break;
                case 1: // right
                    x = canvas.width + 30;
                    y = Math.random() * canvas.height;
                    break;
                case 2: // bottom
                    x = Math.random() * canvas.width;
                    y = canvas.height + 30;
                    break;
                case 3: // left
                    x = -30;
                    y = Math.random() * canvas.height;
                    break;
            }

            const baseSpeed = 1.5 + wave * 0.3;
            const baseSize = 12 + Math.random() * 8;
            
            // Randomly select enemy type (more special types in later waves)
            let enemyType;
            const rand = Math.random();
            if (wave > 5 && rand < 0.3) {
                enemyType = ENEMY_TYPES.JUMPER;
            } else if (wave > 3 && rand < 0.4) {
                enemyType = ENEMY_TYPES.ZIGZAG;
            } else {
                enemyType = ENEMY_TYPES.NORMAL;
            }
            
            const enemy = {
                x: x,
                y: y,
                radius: baseSize,
                speed: baseSpeed,
                color: enemyType === ENEMY_TYPES.JUMPER ? '#ff00ff' : 
                       enemyType === ENEMY_TYPES.ZIGZAG ? '#00ffff' : 
                       `hsl(${Math.random() * 360}, 70%, 50%)`,
                health: 1 + Math.floor(wave / 3),
                type: enemyType,
                // Zigzag specific
                zigzagDir: Math.random() * Math.PI * 2,
                zigzagCounter: 0,
                // Jumper specific
                jumpTimer: 0,
                jumpInterval: 60 + Math.random() * 60, // Frames between jumps
                lastJumpX: x,
                lastJumpY: y,
                barrierCooldown: 0
            };
            
            enemies.push(enemy);
            enemiesSpawned++;
        }

        // Upgrade definitions with tiers
        const UPGRADES = {
            // Common
            fireRate: { 
                rarity: 'rare', // Made rarer
                tiers: [
                    { name: 'Faster Firing I', desc: 'Reduce fire rate by 30ms' },
                    { name: 'Faster Firing II', desc: 'Reduce fire rate by 50ms' },
                    { name: 'Faster Firing III', desc: 'Reduce fire rate by 80ms' }
                ]
            },
            moveSpeed: { 
                rarity: 'common', 
                tiers: [
                    { name: 'Quick Feet I', desc: 'Increase move speed by 1' },
                    { name: 'Quick Feet II', desc: 'Increase move speed by 2' },
                    { name: 'Quick Feet III', desc: 'Increase move speed by 3' }
                ]
            },
            damage: { 
                rarity: 'common', 
                tiers: [
                    { name: 'Power Shot I', desc: 'Increase damage by 1' },
                    { name: 'Power Shot II', desc: 'Increase damage by 2' },
                    { name: 'Power Shot III', desc: 'Increase damage by 3' }
                ]
            },
            health: { 
                rarity: 'common', 
                tiers: [
                    { name: 'Tough Skin I', desc: 'Increase max health by 1' },
                    { name: 'Tough Skin II', desc: 'Increase max health by 2' },
                    { name: 'Tough Skin III', desc: 'Increase max health by 3' }
                ]
            },
            luck: { 
                rarity: 'common', 
                tiers: [
                    { name: 'Lucky I', desc: 'Gain 10 bonus score per kill' },
                    { name: 'Lucky II', desc: 'Gain 20 bonus score per kill' },
                    { name: 'Lucky III', desc: 'Gain 30 bonus score per kill' }
                ]
            },
            armor: { 
                rarity: 'common', 
                tiers: [
                    { name: 'Basic Armor', desc: 'Reduce incoming damage by 0.5' },
                    { name: 'Steel Armor', desc: 'Reduce incoming damage by 1' },
                    { name: 'Titanium Armor', desc: 'Reduce incoming damage by 1.5' }
                ]
            },
            
            // Uncommon - Double Shot becomes Triple becomes Quad
            multiShot: { 
                rarity: 'uncommon', 
                tiers: [
                    { name: 'Double Shot', desc: 'Shoot 2 bullets at once' },
                    { name: 'Triple Shot', desc: 'Shoot 3 bullets in spread' },
                    { name: 'Quad Shot', desc: 'Shoot 4 bullets in wide spread' }
                ]
            },
            healOverTime: { 
                rarity: 'uncommon', 
                tiers: [
                    { name: 'Regeneration I', desc: 'Heal 1 HP every 3 seconds' },
                    { name: 'Regeneration II', desc: 'Heal 1 HP every 2 seconds' },
                    { name: 'Regeneration III', desc: 'Heal 1 HP every 1 second' }
                ]
            },
            fasterBullets: { 
                rarity: 'uncommon', 
                tiers: [
                    { name: 'Swift Projectiles I', desc: 'Bullets move 25% faster' },
                    { name: 'Swift Projectiles II', desc: 'Bullets move 50% faster' },
                    { name: 'Swift Projectiles III', desc: 'Bullets move 75% faster' }
                ]
            },
            pierce: { 
                rarity: 'uncommon', 
                tiers: [
                    { name: 'Piercing I', desc: 'Bullets pierce through 1 enemy' },
                    { name: 'Piercing II', desc: 'Bullets pierce through 2 enemies' },
                    { name: 'Piercing III', desc: 'Bullets pierce through 3 enemies' }
                ]
            },
            critChance: { 
                rarity: 'uncommon', 
                tiers: [
                    { name: 'Critical Strike I', desc: '10% chance for double damage' },
                    { name: 'Critical Strike II', desc: '20% chance for double damage' },
                    { name: 'Critical Strike III', desc: '30% chance for double damage' }
                ]
            },
            
            // Rare
            barriers: { 
                rarity: 'rare', 
                tiers: [
                    { name: 'Barrier Kit I', desc: 'Gain 2 barriers' },
                    { name: 'Barrier Kit II', desc: 'Gain 4 barriers' },
                    { name: 'Barrier Master', desc: 'Gain 1 barrier every round' }
                ]
            },
            shield: { 
                rarity: 'rare', 
                tiers: [
                    { name: 'Energy Shield I', desc: 'Gain 1 extra health' },
                    { name: 'Energy Shield II', desc: 'Gain 2 extra health' },
                    { name: 'Energy Shield III', desc: 'Gain 3 extra health' }
                ]
            },
            rapidFire: { 
                rarity: 'rare', 
                tiers: [
                    { name: 'Rapid Fire I', desc: 'Reduce fire rate by 30%' },
                    { name: 'Rapid Fire II', desc: 'Reduce fire rate by 50%' },
                    { name: 'Rapid Fire III', desc: 'Reduce fire rate by 70%' }
                ]
            },
            vampirism: { 
                rarity: 'rare', 
                tiers: [
                    { name: 'Life Steal I', desc: 'Heal 0.5 HP per kill' },
                    { name: 'Life Steal II', desc: 'Heal 1 HP per kill' },
                    { name: 'Life Steal III', desc: 'Heal 1.5 HP per kill' }
                ]
            },
            explosiveBullets: { 
                rarity: 'rare', 
                tiers: [
                    { name: 'Explosive I', desc: 'Bullets explode on impact, dealing area damage' },
                    { name: 'Explosive II', desc: 'Larger explosions with more damage' },
                    { name: 'Explosive III', desc: 'Massive explosions, devastating area damage' }
                ]
            },
            
            // Legendary
            fullHeal: { 
                rarity: 'legendary', 
                tiers: [
                    { name: 'Full Recovery', desc: 'Restore all health', singleUse: true },
                    { name: 'Full Recovery', desc: 'Restore all health', singleUse: true },
                    { name: 'Full Recovery', desc: 'Restore all health', singleUse: true }
                ]
            },
            instantHeal: { 
                rarity: 'legendary', 
                tiers: [
                    { name: 'Emergency Heal', desc: 'Restore 2 health', singleUse: true },
                    { name: 'Emergency Heal+', desc: 'Restore 3 health', singleUse: true },
                    { name: 'Emergency Heal++', desc: 'Restore 4 health', singleUse: true }
                ]
            },
            bulletSize: { 
                rarity: 'legendary', 
                tiers: [
                    { name: 'Heavy Bullets', desc: 'Bullets are larger and deal more damage' },
                    { name: 'Massive Bullets', desc: 'Bullets are much larger and deal significantly more damage' },
                    { name: 'Mega Bullets', desc: 'Bullets are huge and devastating' }
                ]
            },
            timeSlow: { 
                rarity: 'legendary', 
                tiers: [
                    { name: 'Time Dilation', desc: 'Enemies move 20% slower' },
                    { name: 'Time Warp', desc: 'Enemies move 35% slower' },
                    { name: 'Time Freeze', desc: 'Enemies move 50% slower' }
                ]
            }
        };
        
        // Track upgrade levels
        const upgradeLevels = {};

        // Generate upgrade options
        function generateUpgradeOptions() {
            const options = [];
            const rarities = ['common', 'uncommon', 'rare', 'legendary'];
            
            // Weighted random - higher waves have better chances
            for (let i = 0; i < 3; i++) {
                let rarity;
                const roll = Math.random();
                if (wave > 10 && roll < 0.15) {
                    rarity = 'legendary';
                } else if (wave > 5 && roll < 0.35) {
                    rarity = 'rare';
                } else if (wave > 2 && roll < 0.6) {
                    rarity = 'uncommon';
                } else {
                    rarity = 'common';
                }
                
                // Get upgrades of this rarity
                const rarityUpgrades = Object.entries(UPGRADES)
                    .filter(([key, upgrade]) => upgrade.rarity === rarity)
                    .map(([key]) => key);
                
                if (rarityUpgrades.length > 0) {
                    const randomKey = rarityUpgrades[Math.floor(Math.random() * rarityUpgrades.length)];
                    const level = upgradeLevels[randomKey] || 0;
                    
                    // Check if upgrade has more tiers
                    if (level < UPGRADES[randomKey].tiers.length) {
                        const tier = UPGRADES[randomKey].tiers[level];
                        options.push({ 
                            key: randomKey, 
                            level: level,
                            name: tier.name,
                            desc: tier.desc,
                            rarity: rarity
                        });
                    } else {
                        // Max level reached, try another upgrade or reduce tier
                        i--; // Try again
                    }
                }
            }
            
            return options;
        }

        // Show upgrade selection
        function showUpgradeSelection() {
            wavePaused = true;
            const options = generateUpgradeOptions();
            const container = document.getElementById('upgradeOptions');
            container.innerHTML = '';
            
            options.forEach(upgrade => {
                const option = document.createElement('div');
                option.className = `upgrade-option ${upgrade.rarity}`;
                option.innerHTML = `
                    <h3>${upgrade.name}</h3>
                    <p>${upgrade.desc}</p>
                `;
                option.onclick = () => applyUpgrade(upgrade.key, upgrade.level);
                container.appendChild(option);
            });
            
            document.getElementById('upgradeSelection').style.display = 'block';
        }

        // Apply upgrade
        function applyUpgrade(key, level) {
            // Update upgrade level
            if (!upgradeLevels[key]) {
                upgradeLevels[key] = 0;
            }
            upgradeLevels[key] = level + 1;
            
            switch(key) {
                case 'fireRate':
                    if (level === 0) {
                        player.fireRate = Math.max(100, player.fireRate - 30); // Nerfed
                    } else if (level === 1) {
                        player.fireRate = Math.max(100, player.fireRate - 50); // Nerfed
                    } else {
                        player.fireRate = Math.max(100, player.fireRate - 80); // Nerfed
                    }
                    break;
                case 'moveSpeed':
                    player.moveSpeed += (level + 1);
                    break;
                case 'damage':
                    player.damage += (level + 1);
                    break;
                case 'luck':
                    player.luckLevel = (player.luckLevel || 0) + (level + 1);
                    break;
                case 'armor':
                    player.armorLevel = (player.armorLevel || 0) + (level + 1);
                    break;
                case 'pierce':
                    player.pierceLevel = (player.pierceLevel || 0) + (level + 1);
                    break;
                case 'critChance':
                    player.critChanceLevel = (player.critChanceLevel || 0) + (level + 1);
                    break;
                case 'vampirism':
                    player.vampirismLevel = (player.vampirismLevel || 0) + (level + 1);
                    break;
                case 'explosiveBullets':
                    player.explosiveLevel = (player.explosiveLevel || 0) + (level + 1);
                    break;
                case 'health':
                    const healthBoost = level + 1;
                    player.maxHealth += healthBoost;
                    player.health += healthBoost;
                    break;
                case 'multiShot':
                    if (level === 0) {
                        player.shotMode = 'double';
                    } else if (level === 1) {
                        player.shotMode = 'triple';
                    } else {
                        player.shotMode = 'quad';
                    }
                    break;
                case 'healOverTime':
                    player.healOverTime = true;
                    player.healLevel = level + 1; // Track heal speed level
                    break;
                case 'fasterBullets':
                    player.fasterBullets = true;
                    player.bulletSpeedLevel = level + 1; // Track speed level
                    break;
                case 'barriers':
                    if (level === 2) {
                        // Final tier: gain 1 barrier every round
                        player.barrierPerRound = true;
                        player.barriers += 1;
                    } else {
                        const barrierCount = level === 0 ? 2 : 4;
                        player.barriers += barrierCount;
                    }
                    player.maxBarriers = Math.max(player.maxBarriers, player.barriers);
                    // Show popup for barriers only the first time
                    if (!barrierMessageShown) {
                        alert('Barriers unlocked! Press B key to place a barrier at your cursor. Barriers block enemies and break after taking hits.');
                        barrierMessageShown = true;
                    }
                    break;
                case 'shield':
                    const shieldBoost = level + 1;
                    player.maxHealth += shieldBoost;
                    player.health += shieldBoost;
                    break;
                case 'fullHeal':
                    player.health = player.maxHealth;
                    break;
                case 'instantHeal':
                    const healAmount = level + 2; // 2, 3, or 4 health
                    player.health = Math.min(player.maxHealth, player.health + healAmount);
                    break;
                case 'bulletSize':
                    player.bulletSizeLevel = level + 1; // Track bullet size level
                    break;
                case 'timeSlow':
                    player.timeSlowLevel = level + 1; // Track time slow level
                    break;
                case 'rapidFire':
                    if (level === 0) {
                        player.fireRate = Math.max(150, player.fireRate * 0.85); // Nerfed - less effective
                    } else if (level === 1) {
                        player.fireRate = Math.max(150, player.fireRate * 0.75); // Nerfed - less effective
                    } else {
                        player.fireRate = Math.max(150, player.fireRate * 0.65); // Nerfed - less effective
                    }
                    break;
            }
            
            document.getElementById('upgradeSelection').style.display = 'none';
            wavePaused = false;
            nextWave();
        }

        // Next wave
        function nextWave() {
            wave++;
            enemiesSpawned = 0;
            enemiesPerWave = 5 + wave * 2;
            enemiesRemaining = enemiesPerWave; // Reset remaining counter
            enemySpawnRate = Math.max(500, enemySpawnRate - 100);
            
            // Give barrier if player has barrier per round upgrade
            if (player.barrierPerRound) {
                player.barriers += 1;
            }
            
            document.getElementById('wave').textContent = wave;
            document.getElementById('enemiesRemaining').textContent = enemiesRemaining;
            document.getElementById('totalEnemies').textContent = enemiesPerWave;
            // Reset spawn timer to start next wave immediately
            lastEnemySpawn = Date.now();
        }

        // Create particles
        function createParticles(x, y, color, count = 5) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 30,
                    maxLife: 30,
                    color: color,
                    size: Math.random() * 3 + 1
                });
            }
        }

        // Update player
        function updatePlayer() {
            if (wavePaused) return;
            
            // Heal over time
            if (player.healOverTime) {
                const now = Date.now();
                const healInterval = player.healLevel === 1 ? 3000 : (player.healLevel === 2 ? 2000 : 1000);
                if (now - lastHealTime > healInterval) {
                    if (player.health < player.maxHealth) {
                        player.health = Math.min(player.maxHealth, player.health + 1);
                        lastHealTime = now;
                    }
                }
            }
            
            // WASD movement
            if (keys['w']) {
                player.y = Math.max(player.size, player.y - player.moveSpeed);
            }
            if (keys['s']) {
                player.y = Math.min(canvas.height - player.size, player.y + player.moveSpeed);
            }
            if (keys['a']) {
                player.x = Math.max(player.size, player.x - player.moveSpeed);
            }
            if (keys['d']) {
                player.x = Math.min(canvas.width - player.size, player.x + player.moveSpeed);
            }

            // Rotate with arrow keys - takes priority over mouse
            if (keys['arrowleft']) {
                player.angle -= player.speed * 8;
            }
            if (keys['arrowright']) {
                player.angle += player.speed * 8;
            }
            
            // Rotate toward mouse only if arrow keys are not pressed
            if (!keys['arrowleft'] && !keys['arrowright']) {
                const dx = mouseX - player.x;
                const dy = mouseY - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Only rotate if mouse is within reasonable distance
                if (distance > 10) {
                    const targetAngle = Math.atan2(dy, dx);
                    let angleDiff = targetAngle - player.angle;
                    
                    // Normalize angle difference to [-PI, PI]
                    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    
                    // Reduce angular momentum - faster, more direct rotation
                    player.angle += angleDiff * 0.3;
                }
            }
        }

        // Update bullets
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.x += Math.cos(bullet.angle) * bullet.speed;
                bullet.y += Math.sin(bullet.angle) * bullet.speed;

                // Remove if out of bounds
                if (bullet.x < 0 || bullet.x > canvas.width || 
                    bullet.y < 0 || bullet.y > canvas.height) {
                    bullets.splice(i, 1);
                    continue;
                }

                // Check collision with enemies
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    const dx = bullet.x - enemy.x;
                    const dy = bullet.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // Use bullet radius with size multiplier
                    const bulletRadius = bullet.radius * (1 + (bullet.sizeMultiplier || 0));
                    
                    if (distance < bulletRadius + enemy.radius) {
                        // Hit!
                        let shouldRemove = true;
                        
                        // Check pierce
                        if (bullet.pierceCount > 0) {
                            bullet.pierceCount--;
                            shouldRemove = false;
                        }
                        
                        // Apply damage
                        let finalDamage = bullet.damage;
                        
                        // Handle explosive bullets
                        if (bullet.explosiveLevel > 0) {
                            const explosionRadius = 50 + (bullet.explosiveLevel * 20);
                            const explosionDamage = finalDamage * (0.5 + bullet.explosiveLevel * 0.2);
                            
                            // Damage all enemies in explosion radius
                            for (let k = enemies.length - 1; k >= 0; k--) {
                                const nearbyEnemy = enemies[k];
                                if (k === j) continue; // Already processing this one
                                
                                const expDx = bullet.x - nearbyEnemy.x;
                                const expDy = bullet.y - nearbyEnemy.y;
                                const expDist = Math.sqrt(expDx * expDx + expDy * expDy);
                                
                                if (expDist < explosionRadius) {
                                    nearbyEnemy.health -= explosionDamage;
                                    createParticles(nearbyEnemy.x, nearbyEnemy.y, '#ff8800', 5);
                                }
                            }
                            createParticles(bullet.x, bullet.y, '#ff8800', 15);
                        }
                        
                        enemy.health -= finalDamage;
                        
                        if (shouldRemove) {
                            bullets.splice(i, 1);
                        }
                        
                        createParticles(enemy.x, enemy.y, enemy.color, 8);
                        
                        if (enemy.health <= 0) {
                            enemies.splice(j, 1);
                            enemiesRemaining--; // Decrease remaining counter
                            let points = 10 + wave * 5;
                            
                            // Apply luck bonus
                            if (player?.luckLevel) {
                                points += player.luckLevel * 10;
                            }
                            
                            score += points;
                            document.getElementById('score').textContent = score;
                            document.getElementById('enemiesRemaining').textContent = enemiesRemaining; // Update display
                            
                            // Apply vampirism
                            if (player?.vampirismLevel) {
                                const healAmount = player.vampirismLevel * 0.5;
                                player.health = Math.min(player.maxHealth, player.health + healAmount);
                            }
                        }
                        break;
                    }
                }
            }
        }

        // Update enemies
        function updateEnemies() {
            // Calculate time slow multiplier
            let timeSlowMultiplier = 1;
            if (player?.timeSlowLevel) {
                timeSlowMultiplier = 1 - (player.timeSlowLevel * 0.15); // 15% per level
            }
            const collisionTimestamp = Date.now();
            
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                enemy.barrierCooldown = Math.max(0, (enemy.barrierCooldown || 0) - 1);
                
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    // Apply time slow to enemy speed
                    const currentSpeed = enemy.speed * timeSlowMultiplier;
                    
                    if (enemy.type === ENEMY_TYPES.JUMPER) {
                        // Jumper enemy - teleports in steps
                        enemy.jumpTimer++;
                        if (enemy.jumpTimer >= enemy.jumpInterval) {
                            // Jump toward player
                            const jumpDistance = 80 + Math.random() * 40;
                            const angle = Math.atan2(dy, dx);
                            enemy.x = player.x - Math.cos(angle) * jumpDistance;
                            enemy.y = player.y - Math.sin(angle) * jumpDistance;
                            
                            // Keep in bounds
                            enemy.x = Math.max(enemy.radius, Math.min(canvas.width - enemy.radius, enemy.x));
                            enemy.y = Math.max(enemy.radius, Math.min(canvas.height - enemy.radius, enemy.y));
                            
                            enemy.jumpTimer = 0;
                            enemy.jumpInterval = 60 + Math.random() * 60;
                            enemy.lastJumpX = enemy.x;
                            enemy.lastJumpY = enemy.y;
                            
                            // Create teleport effect
                            createParticles(enemy.x, enemy.y, enemy.color, 10);
                        } else {
                            // Move slowly toward player between jumps
                            enemy.x += (dx / distance) * currentSpeed * 0.3;
                            enemy.y += (dy / distance) * currentSpeed * 0.3;
                        }
                    } else if (enemy.type === ENEMY_TYPES.ZIGZAG) {
                        // Zigzag enemy - moves in a zigzag pattern
                        enemy.zigzagCounter++;
                        if (enemy.zigzagCounter > 30) {
                            // Change zigzag direction
                            enemy.zigzagDir += (Math.random() - 0.5) * Math.PI / 2;
                            enemy.zigzagCounter = 0;
                        }
                        
                        // Move toward player with zigzag offset
                        const towardAngle = Math.atan2(dy, dx);
                        const zigzagAngle = towardAngle + Math.sin(enemy.zigzagCounter / 10) * Math.PI / 3;
                        
                        enemy.x += Math.cos(zigzagAngle) * currentSpeed * 1.2;
                        enemy.y += Math.sin(zigzagAngle) * currentSpeed * 1.2;
                    } else {
                        // Normal enemy - direct movement toward player
                        enemy.x += (dx / distance) * enemy.speed;
                        enemy.y += (dy / distance) * enemy.speed;
                    }
                }

                // Check collision with barriers
                for (let k = barriers.length - 1; k >= 0; k--) {
                    const barrier = barriers[k];
                    const barrierDx = enemy.x - barrier.x;
                    const barrierDy = enemy.y - barrier.y;
                    
                    // Rotate barrier bounds
                    const cos = Math.cos(barrier.angle);
                    const sin = Math.sin(barrier.angle);
                    const localX = barrierDx * cos + barrierDy * sin;
                    const localY = -barrierDx * sin + barrierDy * cos;

                    const halfWidth = barrier.width / 2;
                    const halfHeight = barrier.height / 2;

                    if (Math.abs(localX) <= halfWidth + enemy.radius &&
                        Math.abs(localY) <= halfHeight + enemy.radius) {

                        const overlapX = halfWidth + enemy.radius - Math.abs(localX);
                        const overlapY = halfHeight + enemy.radius - Math.abs(localY);

                        let correctedLocalX = localX;
                        let correctedLocalY = localY;

                        if (overlapX < overlapY) {
                            const sign = localX >= 0 ? 1 : -1;
                            correctedLocalX = sign * (halfWidth + enemy.radius + 0.5);
                        } else {
                            const sign = localY >= 0 ? 1 : -1;
                            correctedLocalY = sign * (halfHeight + enemy.radius + 0.5);
                        }

                        const worldX = barrier.x + correctedLocalX * cos - correctedLocalY * sin;
                        const worldY = barrier.y + correctedLocalX * sin + correctedLocalY * cos;

                        enemy.x = worldX;
                        enemy.y = worldY;

                        if ((enemy.barrierCooldown || 0) === 0) {
                            barrier.life = Math.max(0, (barrier.life || barrier.maxLife) - 1);
                            barrier.lastHitAt = Date.now();
                            enemy.barrierCooldown = 8;
                            createParticles(enemy.x, enemy.y, '#00ffff', 6);
                        }

                        if ((barrier.life || 0) <= 0) {
                            barriers.splice(k, 1);
                            createParticles(barrier.x, barrier.y, '#00ffff', 18);
                        }
                    }
                }
                
                // Check collision with player
                const playerDx = enemy.x - player.x;
                const playerDy = enemy.y - player.y;
                const playerDistance = Math.sqrt(playerDx * playerDx + playerDy * playerDy);

                if (playerDistance < enemy.radius + player.size) {
                    // Player hit!
                    enemies.splice(i, 1);
                    
                    // Apply armor reduction
                    let damageTaken = 1;
                    if (player?.armorLevel) {
                        damageTaken = Math.max(0.5, damageTaken - (player.armorLevel * 0.5));
                    }
                    
                    player.health -= damageTaken;
                    createParticles(player.x, player.y, '#ff0000', 15);
                    
                    if (player.health <= 0) {
                        gameOver();
                    }
                }
            }
        }

        // Update particles
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        // Update barriers - they only decay when hit, not over time
        function updateBarriers() {
            // Barriers don't decay over time - only when hit by enemies
            // This function is kept for future use but currently does nothing
        }

        // Draw functions
        function drawPlayer() {
            // Ensure player position is valid before drawing
            if (!player || isNaN(player.x) || isNaN(player.y)) {
                player.x = canvas.width / 2;
                player.y = canvas.height / 2;
            }
            
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.angle);

            // Draw triangle
            ctx.beginPath();
            ctx.moveTo(player.size, 0);
            ctx.lineTo(-player.size, -player.size * 0.8);
            ctx.lineTo(-player.size, player.size * 0.8);
            ctx.closePath();
            
            const gradient = ctx.createLinearGradient(-player.size, 0, player.size, 0);
            gradient.addColorStop(0, player.health > 0 ? '#00ff00' : '#ff0000');
            gradient.addColorStop(1, player.health > 0 ? '#00aa00' : '#aa0000');
            ctx.fillStyle = gradient;
            ctx.fill();
            
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.restore();

            // Draw health bar
            const barWidth = 60;
            const barHeight = 8;
            const barX = player.x - barWidth / 2;
            const barY = player.y - player.size - 20;
            
            ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
            ctx.fillRect(barX, barY, barWidth, barHeight);
            
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(barX, barY, barWidth * (player.health / player.maxHealth), barHeight);
            
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.strokeRect(barX, barY, barWidth, barHeight);
        }

        function drawBullets() {
            bullets.forEach(bullet => {
                // Use bullet size from upgrade if available
                const bulletRadius = bullet.radius * (1 + (bullet.sizeMultiplier || 0));
                
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bulletRadius, 0, Math.PI * 2);
                
                const gradient = ctx.createRadialGradient(
                    bullet.x, bullet.y, 0,
                    bullet.x, bullet.y, bulletRadius
                );
                gradient.addColorStop(0, '#ffff00');
                gradient.addColorStop(1, '#ff8800');
                ctx.fillStyle = gradient;
                ctx.fill();
            });
        }

        function drawEnemies() {
            enemies.forEach(enemy => {
                // Main circle
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                ctx.fillStyle = enemy.color;
                ctx.fill();
                
                // Inner circle
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.radius * 0.6, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fill();
            });
        }

        function drawParticles() {
            particles.forEach(p => {
                const alpha = p.life / p.maxLife;
                ctx.fillStyle = p.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawBarriers() {
            barriers.forEach(barrier => {
                const lifeRatio = Math.max(0, barrier.life / barrier.maxLife);
                const fillAlpha = 0.25 + 0.45 * lifeRatio;
                const borderAlpha = 0.4 + 0.6 * lifeRatio;

                ctx.save();
                ctx.translate(barrier.x, barrier.y);
                ctx.rotate(barrier.angle);
                
                ctx.fillStyle = `rgba(0, 255, 255, ${fillAlpha})`;
                ctx.fillRect(-barrier.width / 2, -barrier.height / 2, barrier.width, barrier.height);
                
                ctx.strokeStyle = `rgba(0, 255, 255, ${borderAlpha})`;
                ctx.lineWidth = 2.5;
                ctx.strokeRect(-barrier.width / 2, -barrier.height / 2, barrier.width, barrier.height);

                // Health bar
                const barWidth = barrier.width;
                const barHeight = 6;
                ctx.fillStyle = 'rgba(10, 30, 35, 0.8)';
                ctx.fillRect(-barWidth / 2, -barrier.height / 2 - 12, barWidth, barHeight);
                ctx.fillStyle = `rgba(0, 255, 255, ${0.6 + 0.4 * lifeRatio})`;
                ctx.fillRect(-barWidth / 2, -barrier.height / 2 - 12, barWidth * lifeRatio, barHeight);
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)';
                ctx.lineWidth = 1;
                ctx.strokeRect(-barWidth / 2, -barrier.height / 2 - 12, barWidth, barHeight);
                
                ctx.restore();
            });
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.1)';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 40) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            drawBarriers();
            drawEnemies();
            drawBullets();
            drawPlayer();
            drawParticles();
            
            // Draw barrier count if available
            if (player.barriers > 0) {
                ctx.fillStyle = '#00ffff';
                ctx.font = '20px Courier New';
                ctx.textAlign = 'left';
                ctx.fillText(`Barriers: ${player.barriers}`, 10, 30);
            }
        }

        // Game loop
        function gameLoop() {
            if (gameRunning) {
                // Update game time
                gameTime = Math.floor((Date.now() - gameStartTime) / 1000);
                document.getElementById('time').textContent = gameTime;
                document.getElementById('enemiesRemaining').textContent = enemiesRemaining;

                // Check for wave completion (all enemies spawned AND all enemies killed)
                if (enemiesSpawned >= enemiesPerWave && enemies.length === 0 && enemiesSpawned > 0 && !waveCompleted && !wavePaused) {
                    waveCompleted = true;
                    showUpgradeSelection();
                }
                
                // Reset wave completion flag when new wave starts spawning (enemies are being spawned again)
                if (waveCompleted && enemiesSpawned > 0 && enemiesSpawned < enemiesPerWave) {
                    waveCompleted = false;
                }

                // Spawn enemies
                const now = Date.now();
                if (now - lastEnemySpawn > enemySpawnRate && enemiesSpawned < enemiesPerWave) {
                    spawnEnemy();
                    lastEnemySpawn = now;
                }

                updatePlayer();
                
                // Continuous shooting when autoshoot is enabled and toggled on
                if (autoshootEnabled && isContinuouslyShooting && gameRunning && !wavePaused) {
                    const now = Date.now();
                    if (now - lastShotTime >= player.fireRate) {
                        fireBullet();
                    }
                }
                
                updateBullets();
                updateEnemies();
                updateBarriers();
                updateParticles();
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        function gameOver() {
            gameRunning = false;
            
            // CRITICAL: Completely disable canvas
            canvas.style.pointerEvents = 'none';
            canvas.style.zIndex = '1';
            canvas.setAttribute('tabindex', '-1');
            
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalTime').textContent = gameTime;
            document.getElementById('finalWave').textContent = wave - 1;
            
            const gameOverDiv = document.getElementById('gameOver');
            gameOverDiv.style.display = 'block';
            gameOverDiv.style.pointerEvents = 'auto';
            gameOverDiv.style.zIndex = '99999';
            
            // Get input and button
            const nameInput = document.getElementById('playerName');
            const saveBtn = document.getElementById('saveScoreBtn');
            
            // Enable input - keep it simple like the fruit input
            if (nameInput) {
                // Set input mode active FIRST - this disables ALL game keyboard handlers
                inputModeActive = true;
                
                nameInput.value = '';
                nameInput.disabled = false;
                nameInput.readOnly = false;
                nameInput.removeAttribute('readonly');
                nameInput.removeAttribute('disabled');
                nameInput.style.pointerEvents = 'auto';
                nameInput.style.zIndex = '100000';
                nameInput.tabIndex = 0;
                
                // Make sure input can receive focus
                nameInput.focus();
                
                console.log('Name input ready - disabled:', nameInput.disabled, 'readOnly:', nameInput.readOnly, 'inputModeActive:', inputModeActive);
            }
            
            if (saveBtn) {
                saveBtn.disabled = false;
                saveBtn.textContent = 'Save Score';
                saveBtn.style.background = 'linear-gradient(135deg, #00ff00, #00aa00)';
            }
            
            // Focus input after DOM updates
            setTimeout(() => {
                if (nameInput) {
                    nameInput.focus();
                }
            }, 150);
            
            // Load leaderboard
            if (typeof loadLeaderboard === 'function') {
                loadLeaderboard();
            }
        }

        // Make resetGame accessible globally
        window.resetGame = function() {
            gameRunning = true;
            wavePaused = false;
            score = 0;
            wave = 1;
            gameTime = 0;
            gameStartTime = Date.now();
            lastEnemySpawn = Date.now();
            lastShotTime = Date.now();
            lastHealTime = Date.now();
            spacePressed = false;
            isContinuouslyShooting = false; // Reset continuous shooting
            inputModeActive = false; // Reset input mode
            enemySpawnRate = 1500;
            enemiesPerWave = 5;
            enemiesSpawned = 0;
            enemiesRemaining = enemiesPerWave;
            waveCompleted = false;
            barrierMessageShown = false;
            
            // Reset upgrade levels
            Object.keys(upgradeLevels).forEach(key => {
                upgradeLevels[key] = 0;
            });
            
            // Ensure player position is valid
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            
            // Make sure player is visible
            if (!player.x || !player.y || isNaN(player.x) || isNaN(player.y)) {
                player.x = canvas.width / 2;
                player.y = canvas.height / 2;
            }
            player.health = 3;
            player.maxHealth = 3;
            player.barrierPerRound = false;
            player.bulletSizeLevel = 0;
            player.timeSlowLevel = 0;
            player.luckLevel = 0;
            player.armorLevel = 0;
            player.pierceLevel = 0;
            player.critChanceLevel = 0;
            player.vampirismLevel = 0;
            player.explosiveLevel = 0;
            player.fireRate = 500; // Nerfed base rate
            player.damage = 1;
            player.moveSpeed = 5;
            player.shotMode = 'single';
            player.healOverTime = false;
            player.healLevel = 0;
            player.barriers = 0;
            player.maxBarriers = 0;
            player.fasterBullets = false;
            player.bulletSpeedLevel = 0;
            
            // Reset upgrade levels
            Object.keys(upgradeLevels).forEach(key => delete upgradeLevels[key]);
            
            bullets.length = 0;
            enemies.length = 0;
            particles.length = 0;
            barriers.length = 0;
            
            enemiesRemaining = enemiesPerWave; // Reset remaining counter
            
            document.getElementById('score').textContent = score;
            document.getElementById('wave').textContent = wave;
            document.getElementById('enemiesRemaining').textContent = enemiesRemaining;
            document.getElementById('totalEnemies').textContent = enemiesPerWave;
            document.getElementById('time').textContent = 0;
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('upgradeSelection').style.display = 'none';
            
            // Re-enable canvas pointer events
            canvas.style.pointerEvents = 'auto';
        };

        // Initialize - set total enemies display
        enemiesRemaining = enemiesPerWave;
        document.getElementById('enemiesRemaining').textContent = enemiesRemaining;
        document.getElementById('totalEnemies').textContent = enemiesPerWave;
        gameLoop();
    </script>
</body>
</html>
