<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SECRET GAME - Triangle Defense</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
            color: #00ff00;
        }

        /* Game-like border effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 8px solid #ff0000;
            box-shadow: 
                0 0 20px #ff0000,
                inset 0 0 20px rgba(255, 0, 0, 0.1);
            pointer-events: none;
            z-index: 1;
        }

        /* Corner decorations */
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                linear-gradient(90deg, #ff0000 2px, transparent 2px),
                linear-gradient(180deg, #ff0000 2px, transparent 2px);
            background-size: 40px 40px;
            opacity: 0.1;
            pointer-events: none;
            z-index: 0;
        }

        .game-container {
            position: relative;
            z-index: 2;
            width: 1400px;
            height: 900px;
            background: #1a1a2e;
            border: 4px solid #ff0000;
            box-shadow: 
                0 0 30px rgba(255, 0, 0, 0.5),
                inset 0 0 30px rgba(255, 0, 0, 0.1);
            padding: 20px;
        }

        h1 {
            color: #ff0000;
            font-size: 2em;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #ff0000;
        }

        .subtitle {
            color: #ff0000;
            text-align: center;
            margin-bottom: 15px;
            opacity: 0.8;
            font-size: 0.9em;
        }

        #gameCanvas {
            border: 2px solid #ff0000;
            background: #0a0a1a;
            display: block;
            margin: 0 auto;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);
        }

        .upgrade-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
        }

        .upgrade-btn {
            padding: 8px 15px;
            background: linear-gradient(135deg, #1a1a2e, #2a2a4e);
            border: 2px solid #00ff00;
            color: #00ff00;
            font-size: 0.9em;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 5px #00ff00;
            border-radius: 5px;
        }

        .upgrade-btn:hover {
            background: linear-gradient(135deg, #2a2a4e, #3a3a6e);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.8);
            transform: scale(1.05);
        }

        .upgrade-selection {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 4px solid #ff0000;
            border-radius: 10px;
            padding: 30px;
            display: none;
            z-index: 1000;
            box-shadow: 0 0 50px rgba(255, 0, 0, 0.8);
            min-width: 600px;
            text-align: center;
        }

        .upgrade-selection h2 {
            color: #ff0000;
            font-size: 2em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff0000;
        }

        .upgrade-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .upgrade-option {
            padding: 15px;
            border: 3px solid;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            background: rgba(26, 26, 46, 0.8);
        }

        .upgrade-option:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px currentColor;
        }

        .upgrade-option.common {
            border-color: #808080;
            color: #808080;
        }

        .upgrade-option.uncommon {
            border-color: #00ff00;
            color: #00ff00;
        }

        .upgrade-option.rare {
            border-color: #0080ff;
            color: #0080ff;
        }

        .upgrade-option.legendary {
            border-color: #ff8000;
            color: #ff8000;
            animation: legendary-glow 2s infinite;
        }

        @keyframes legendary-glow {
            0%, 100% { box-shadow: 0 0 10px #ff8000; }
            50% { box-shadow: 0 0 30px #ff8000; }
        }

        .upgrade-option h3 {
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .upgrade-option p {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .barrier {
            position: absolute;
            width: 100px;
            height: 10px;
            background: rgba(0, 255, 255, 0.5);
            border: 2px solid #00ffff;
            border-radius: 5px;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
            color: #ff0000;
            font-size: 1.1em;
            font-weight: bold;
        }

        .stat-item {
            padding: 8px 15px;
            background: rgba(255, 0, 0, 0.1);
            border: 2px solid #ff0000;
            border-radius: 5px;
            min-width: 150px;
            text-align: center;
        }

        .controls {
            text-align: center;
            color: #ff0000;
            margin-top: 10px;
            font-size: 0.85em;
        }

        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border: 4px solid #ff0000;
            border-radius: 10px;
            color: #ff0000;
            text-align: center;
            display: none;
            z-index: 1000;
            box-shadow: 0 0 50px rgba(255, 0, 0, 0.8);
        }

        .game-over h2 {
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff0000;
        }

        .game-over button {
            background: linear-gradient(135deg, #ff0000, #aa0000);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
            margin-right: 10px;
            transition: transform 0.2s;
            font-family: 'Courier New', monospace;
        }

        .game-over button:hover {
            transform: scale(1.05);
        }

        .nav-button {
            background: linear-gradient(135deg, #ff0000, #aa0000);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>⚠ SECRET GAME ⚠</h1>
        <div class="subtitle">>> TRIANGLE DEFENSE - SURVIVE AS LONG AS POSSIBLE <<</div>
        
        <canvas id="gameCanvas" width="1360" height="700"></canvas>
        
        <div class="stats">
            <div class="stat-item">Score: <span id="score">0</span></div>
            <div class="stat-item">Wave: <span id="wave">1</span></div>
            <div class="stat-item">Enemies: <span id="enemies">0</span> / <span id="totalEnemies">0</span></div>
            <div class="stat-item">Time: <span id="time">0</span>s</div>
        </div>

        <div class="controls">
            <p>Use ← → Arrow Keys or Mouse to Rotate | Click or Space to Shoot | WASD to Move | B to Place Barrier | ESC to Exit</p>
        </div>
    </div>

    <div class="upgrade-selection" id="upgradeSelection">
        <h2>WAVE COMPLETE!</h2>
        <p style="color: #ff0000; margin-bottom: 20px;">Choose an Upgrade:</p>
        <div class="upgrade-options" id="upgradeOptions">
            <!-- Upgrade options will be generated here -->
        </div>
    </div>

    <div class="game-over" id="gameOver">
        <h2>GAME OVER!</h2>
        <p>Final Score: <span id="finalScore">0</span></p>
        <p>Time Survived: <span id="finalTime">0</span>s</p>
        <p>Waves Completed: <span id="finalWave">0</span></p>
        <button onclick="resetGame()">Play Again</button>
        <button onclick="window.location.href='index.html'" class="nav-button">Back to Home</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let score = 0;
        let wave = 1;
        let gameTime = 0;
        let gameRunning = true;
        let wavePaused = false;
        let gameStartTime = Date.now();
        let lastEnemySpawn = Date.now();
        let lastShotTime = Date.now();
        let lastHealTime = Date.now();
        let enemySpawnRate = 1500; // milliseconds
        let enemiesPerWave = 5;
        let enemiesSpawned = 0;
        let waveCompleted = false;

        // Player (triangle)
        const player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            angle: 0,
            size: 25,
            speed: 0.05,
            moveSpeed: 5,
            color: '#00ff00',
            health: 3,
            maxHealth: 3,
            fireRate: 200, // milliseconds between shots
            damage: 1,
            // Upgrade abilities
            shotMode: 'single', // single, double, triple, quad
            healOverTime: false,
            barriers: 0, // Number of barriers available
            maxBarriers: 0,
            fasterBullets: false
        };

        // Bullets array
        const bullets = [];

        // Enemies array
        const enemies = [];

        // Particles array for effects
        const particles = [];

        // Barriers array
        const barriers = [];

        // Mouse position
        let mouseX = canvas.width / 2;
        let mouseY = canvas.height / 2;

        // Keyboard state
        const keys = {};

        // Enemy types
        const ENEMY_TYPES = {
            NORMAL: 'normal',
            ZIGZAG: 'zigzag',
            JUMPER: 'jumper'
        };

        // Event listeners
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        canvas.addEventListener('click', (e) => {
            if (gameRunning && !wavePaused) {
                shoot();
            }
        });

        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            keys[key] = true;
            
            // Handle Escape key to exit game
            if (e.key === 'Escape') {
                if (confirm('Leave the game and return to home?')) {
                    window.location.href = 'index.html';
                }
                return;
            }
            
            if (e.key === ' ' && gameRunning && !wavePaused) {
                e.preventDefault();
                if (!wavePaused) {
                    shoot();
                }
            }
            // Place barrier with 'B' key
            if (e.key.toLowerCase() === 'b' && gameRunning && !wavePaused && player.barriers > 0) {
                e.preventDefault();
                placeBarrier();
            }
            if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
                e.preventDefault();
            }
            // Prevent default for WASD keys
            if (['w', 'a', 's', 'd'].includes(key)) {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            keys[key] = false;
        });

        // Shoot function
        function shoot() {
            const now = Date.now();
            if (now - lastShotTime < player.fireRate) {
                return; // Too soon to shoot
            }
            lastShotTime = now;
            
            let bulletSpeed = 12;
            if (player.fasterBullets) {
                if (player.bulletSpeedLevel === 1) {
                    bulletSpeed = 15; // 25% faster
                } else if (player.bulletSpeedLevel === 2) {
                    bulletSpeed = 18; // 50% faster
                } else {
                    bulletSpeed = 21; // 75% faster
                }
            }
            const angles = [];
            
            switch(player.shotMode) {
                case 'single':
                    angles = [0];
                    break;
                case 'double':
                    angles = [-0.15, 0.15];
                    break;
                case 'triple':
                    angles = [-0.2, 0, 0.2];
                    break;
                case 'quad':
                    angles = [-0.25, -0.1, 0.1, 0.25];
                    break;
            }
            
            angles.forEach(offset => {
                bullets.push({
                    x: player.x,
                    y: player.y,
                    angle: player.angle + offset,
                    speed: bulletSpeed,
                    radius: 5,
                    color: '#ffff00',
                    damage: player.damage
                });
            });
        }

        // Place barrier
        function placeBarrier() {
            if (player.barriers <= 0) return;
            
            barriers.push({
                x: player.x + Math.cos(player.angle) * 60,
                y: player.y + Math.sin(player.angle) * 60,
                width: 100,
                height: 10,
                angle: player.angle,
                life: 600 // 10 seconds at 60fps
            });
            
            player.barriers--;
        }

        // Create enemy
        function spawnEnemy() {
            if (!gameRunning) return;
            
            // Spawn enemy from edge of canvas
            const side = Math.floor(Math.random() * 4);
            let x, y;

            switch(side) {
                case 0: // top
                    x = Math.random() * canvas.width;
                    y = -30;
                    break;
                case 1: // right
                    x = canvas.width + 30;
                    y = Math.random() * canvas.height;
                    break;
                case 2: // bottom
                    x = Math.random() * canvas.width;
                    y = canvas.height + 30;
                    break;
                case 3: // left
                    x = -30;
                    y = Math.random() * canvas.height;
                    break;
            }

            const baseSpeed = 1.5 + wave * 0.3;
            const baseSize = 12 + Math.random() * 8;
            
            // Randomly select enemy type (more special types in later waves)
            let enemyType;
            const rand = Math.random();
            if (wave > 5 && rand < 0.3) {
                enemyType = ENEMY_TYPES.JUMPER;
            } else if (wave > 3 && rand < 0.4) {
                enemyType = ENEMY_TYPES.ZIGZAG;
            } else {
                enemyType = ENEMY_TYPES.NORMAL;
            }
            
            const enemy = {
                x: x,
                y: y,
                radius: baseSize,
                speed: baseSpeed,
                color: enemyType === ENEMY_TYPES.JUMPER ? '#ff00ff' : 
                       enemyType === ENEMY_TYPES.ZIGZAG ? '#00ffff' : 
                       `hsl(${Math.random() * 360}, 70%, 50%)`,
                health: 1 + Math.floor(wave / 3),
                type: enemyType,
                // Zigzag specific
                zigzagDir: Math.random() * Math.PI * 2,
                zigzagCounter: 0,
                // Jumper specific
                jumpTimer: 0,
                jumpInterval: 60 + Math.random() * 60, // Frames between jumps
                lastJumpX: x,
                lastJumpY: y
            };
            
            enemies.push(enemy);
            enemiesSpawned++;
        }

        // Upgrade definitions with tiers
        const UPGRADES = {
            // Common
            fireRate: { 
                rarity: 'common', 
                tiers: [
                    { name: 'Faster Firing I', desc: 'Reduce fire rate by 15ms' },
                    { name: 'Faster Firing II', desc: 'Reduce fire rate by 25ms' },
                    { name: 'Faster Firing III', desc: 'Reduce fire rate by 40ms' }
                ]
            },
            moveSpeed: { 
                rarity: 'common', 
                tiers: [
                    { name: 'Quick Feet I', desc: 'Increase move speed by 1' },
                    { name: 'Quick Feet II', desc: 'Increase move speed by 2' },
                    { name: 'Quick Feet III', desc: 'Increase move speed by 3' }
                ]
            },
            damage: { 
                rarity: 'common', 
                tiers: [
                    { name: 'Power Shot I', desc: 'Increase damage by 1' },
                    { name: 'Power Shot II', desc: 'Increase damage by 2' },
                    { name: 'Power Shot III', desc: 'Increase damage by 3' }
                ]
            },
            health: { 
                rarity: 'common', 
                tiers: [
                    { name: 'Tough Skin I', desc: 'Increase max health by 1' },
                    { name: 'Tough Skin II', desc: 'Increase max health by 2' },
                    { name: 'Tough Skin III', desc: 'Increase max health by 3' }
                ]
            },
            
            // Uncommon - Double Shot becomes Triple becomes Quad
            multiShot: { 
                rarity: 'uncommon', 
                tiers: [
                    { name: 'Double Shot', desc: 'Shoot 2 bullets at once' },
                    { name: 'Triple Shot', desc: 'Shoot 3 bullets in spread' },
                    { name: 'Quad Shot', desc: 'Shoot 4 bullets in wide spread' }
                ]
            },
            healOverTime: { 
                rarity: 'uncommon', 
                tiers: [
                    { name: 'Regeneration I', desc: 'Heal 1 HP every 3 seconds' },
                    { name: 'Regeneration II', desc: 'Heal 1 HP every 2 seconds' },
                    { name: 'Regeneration III', desc: 'Heal 1 HP every 1 second' }
                ]
            },
            fasterBullets: { 
                rarity: 'uncommon', 
                tiers: [
                    { name: 'Swift Projectiles I', desc: 'Bullets move 25% faster' },
                    { name: 'Swift Projectiles II', desc: 'Bullets move 50% faster' },
                    { name: 'Swift Projectiles III', desc: 'Bullets move 75% faster' }
                ]
            },
            
            // Rare
            barriers: { 
                rarity: 'rare', 
                tiers: [
                    { name: 'Barrier Kit I', desc: 'Gain 2 barriers' },
                    { name: 'Barrier Kit II', desc: 'Gain 4 barriers' },
                    { name: 'Barrier Master', desc: 'Gain 6 barriers' }
                ]
            },
            shield: { 
                rarity: 'rare', 
                tiers: [
                    { name: 'Energy Shield I', desc: 'Gain 1 extra health' },
                    { name: 'Energy Shield II', desc: 'Gain 2 extra health' },
                    { name: 'Energy Shield III', desc: 'Gain 3 extra health' }
                ]
            },
            rapidFire: { 
                rarity: 'rare', 
                tiers: [
                    { name: 'Rapid Fire I', desc: 'Reduce fire rate by 30%' },
                    { name: 'Rapid Fire II', desc: 'Reduce fire rate by 50%' },
                    { name: 'Rapid Fire III', desc: 'Reduce fire rate by 70%' }
                ]
            },
            
            // Legendary
            fullHeal: { 
                rarity: 'legendary', 
                tiers: [
                    { name: 'Full Recovery', desc: 'Restore all health', singleUse: true },
                    { name: 'Full Recovery', desc: 'Restore all health', singleUse: true },
                    { name: 'Full Recovery', desc: 'Restore all health', singleUse: true }
                ]
            }
        };
        
        // Track upgrade levels
        const upgradeLevels = {};

        // Generate upgrade options
        function generateUpgradeOptions() {
            const options = [];
            const rarities = ['common', 'uncommon', 'rare', 'legendary'];
            
            // Weighted random - higher waves have better chances
            for (let i = 0; i < 3; i++) {
                let rarity;
                const roll = Math.random();
                if (wave > 10 && roll < 0.15) {
                    rarity = 'legendary';
                } else if (wave > 5 && roll < 0.35) {
                    rarity = 'rare';
                } else if (wave > 2 && roll < 0.6) {
                    rarity = 'uncommon';
                } else {
                    rarity = 'common';
                }
                
                // Get upgrades of this rarity
                const rarityUpgrades = Object.entries(UPGRADES)
                    .filter(([key, upgrade]) => upgrade.rarity === rarity)
                    .map(([key]) => key);
                
                if (rarityUpgrades.length > 0) {
                    const randomKey = rarityUpgrades[Math.floor(Math.random() * rarityUpgrades.length)];
                    const level = upgradeLevels[randomKey] || 0;
                    
                    // Check if upgrade has more tiers
                    if (level < UPGRADES[randomKey].tiers.length) {
                        const tier = UPGRADES[randomKey].tiers[level];
                        options.push({ 
                            key: randomKey, 
                            level: level,
                            name: tier.name,
                            desc: tier.desc,
                            rarity: rarity
                        });
                    } else {
                        // Max level reached, try another upgrade or reduce tier
                        i--; // Try again
                    }
                }
            }
            
            return options;
        }

        // Show upgrade selection
        function showUpgradeSelection() {
            wavePaused = true;
            const options = generateUpgradeOptions();
            const container = document.getElementById('upgradeOptions');
            container.innerHTML = '';
            
            options.forEach(upgrade => {
                const option = document.createElement('div');
                option.className = `upgrade-option ${upgrade.rarity}`;
                option.innerHTML = `
                    <h3>${upgrade.name}</h3>
                    <p>${upgrade.desc}</p>
                `;
                option.onclick = () => applyUpgrade(upgrade.key, upgrade.level);
                container.appendChild(option);
            });
            
            document.getElementById('upgradeSelection').style.display = 'block';
        }

        // Apply upgrade
        function applyUpgrade(key, level) {
            // Update upgrade level
            if (!upgradeLevels[key]) {
                upgradeLevels[key] = 0;
            }
            upgradeLevels[key] = level + 1;
            
            switch(key) {
                case 'fireRate':
                    if (level === 0) {
                        player.fireRate = Math.max(50, player.fireRate - 15);
                    } else if (level === 1) {
                        player.fireRate = Math.max(50, player.fireRate - 25);
                    } else {
                        player.fireRate = Math.max(50, player.fireRate - 40);
                    }
                    break;
                case 'moveSpeed':
                    player.moveSpeed += (level + 1);
                    break;
                case 'damage':
                    player.damage += (level + 1);
                    break;
                case 'health':
                    const healthBoost = level + 1;
                    player.maxHealth += healthBoost;
                    player.health += healthBoost;
                    break;
                case 'multiShot':
                    if (level === 0) {
                        player.shotMode = 'double';
                    } else if (level === 1) {
                        player.shotMode = 'triple';
                    } else {
                        player.shotMode = 'quad';
                    }
                    break;
                case 'healOverTime':
                    player.healOverTime = true;
                    player.healLevel = level + 1; // Track heal speed level
                    break;
                case 'fasterBullets':
                    player.fasterBullets = true;
                    player.bulletSpeedLevel = level + 1; // Track speed level
                    break;
                case 'barriers':
                    const barrierCount = level === 0 ? 2 : (level === 1 ? 4 : 6);
                    player.barriers += barrierCount;
                    player.maxBarriers = Math.max(player.maxBarriers, player.barriers);
                    // Show popup for barriers
                    alert('Barriers placed! Press B key to place a barrier in front of your ship. Barriers block enemies and expire after 10 seconds.');
                    break;
                case 'shield':
                    const shieldBoost = level + 1;
                    player.maxHealth += shieldBoost;
                    player.health += shieldBoost;
                    break;
                case 'fullHeal':
                    player.health = player.maxHealth;
                    break;
                case 'rapidFire':
                    if (level === 0) {
                        player.fireRate = Math.max(50, player.fireRate * 0.7);
                    } else if (level === 1) {
                        player.fireRate = Math.max(50, player.fireRate * 0.5);
                    } else {
                        player.fireRate = Math.max(50, player.fireRate * 0.3);
                    }
                    break;
            }
            
            document.getElementById('upgradeSelection').style.display = 'none';
            wavePaused = false;
            nextWave();
        }

        // Next wave
        function nextWave() {
            wave++;
            enemiesSpawned = 0;
            enemiesPerWave = 5 + wave * 2;
            enemySpawnRate = Math.max(500, enemySpawnRate - 100);
            document.getElementById('wave').textContent = wave;
            document.getElementById('totalEnemies').textContent = enemiesPerWave;
            // Reset spawn timer to start next wave immediately
            lastEnemySpawn = Date.now();
        }

        // Create particles
        function createParticles(x, y, color, count = 5) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 30,
                    maxLife: 30,
                    color: color,
                    size: Math.random() * 3 + 1
                });
            }
        }

        // Update player
        function updatePlayer() {
            if (wavePaused) return;
            
            // Heal over time
            if (player.healOverTime) {
                const now = Date.now();
                const healInterval = player.healLevel === 1 ? 3000 : (player.healLevel === 2 ? 2000 : 1000);
                if (now - lastHealTime > healInterval) {
                    if (player.health < player.maxHealth) {
                        player.health = Math.min(player.maxHealth, player.health + 1);
                        lastHealTime = now;
                    }
                }
            }
            
            // WASD movement
            if (keys['w']) {
                player.y = Math.max(player.size, player.y - player.moveSpeed);
            }
            if (keys['s']) {
                player.y = Math.min(canvas.height - player.size, player.y + player.moveSpeed);
            }
            if (keys['a']) {
                player.x = Math.max(player.size, player.x - player.moveSpeed);
            }
            if (keys['d']) {
                player.x = Math.min(canvas.width - player.size, player.x + player.moveSpeed);
            }

            // Rotate with arrow keys - takes priority over mouse
            if (keys['arrowleft']) {
                player.angle -= player.speed * 8;
            }
            if (keys['arrowright']) {
                player.angle += player.speed * 8;
            }
            
            // Rotate toward mouse only if arrow keys are not pressed
            if (!keys['arrowleft'] && !keys['arrowright']) {
                const dx = mouseX - player.x;
                const dy = mouseY - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Only rotate if mouse is within reasonable distance
                if (distance > 10) {
                    const targetAngle = Math.atan2(dy, dx);
                    let angleDiff = targetAngle - player.angle;
                    
                    // Normalize angle difference to [-PI, PI]
                    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    
                    // Reduce angular momentum - faster, more direct rotation
                    player.angle += angleDiff * 0.3;
                }
            }
        }

        // Update bullets
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.x += Math.cos(bullet.angle) * bullet.speed;
                bullet.y += Math.sin(bullet.angle) * bullet.speed;

                // Remove if out of bounds
                if (bullet.x < 0 || bullet.x > canvas.width || 
                    bullet.y < 0 || bullet.y > canvas.height) {
                    bullets.splice(i, 1);
                    continue;
                }

                // Check collision with enemies
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    const dx = bullet.x - enemy.x;
                    const dy = bullet.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < bullet.radius + enemy.radius) {
                        // Hit!
                        bullets.splice(i, 1);
                        enemy.health -= bullet.damage;
                        
                        createParticles(enemy.x, enemy.y, enemy.color, 8);
                        
                        if (enemy.health <= 0) {
                            enemies.splice(j, 1);
                            const points = 10 + wave * 5;
                            score += points;
                            document.getElementById('score').textContent = score;
                        }
                        break;
                    }
                }
            }
        }

        // Update enemies
        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    if (enemy.type === ENEMY_TYPES.JUMPER) {
                        // Jumper enemy - teleports in steps
                        enemy.jumpTimer++;
                        if (enemy.jumpTimer >= enemy.jumpInterval) {
                            // Jump toward player
                            const jumpDistance = 80 + Math.random() * 40;
                            const angle = Math.atan2(dy, dx);
                            enemy.x = player.x - Math.cos(angle) * jumpDistance;
                            enemy.y = player.y - Math.sin(angle) * jumpDistance;
                            
                            // Keep in bounds
                            enemy.x = Math.max(enemy.radius, Math.min(canvas.width - enemy.radius, enemy.x));
                            enemy.y = Math.max(enemy.radius, Math.min(canvas.height - enemy.radius, enemy.y));
                            
                            enemy.jumpTimer = 0;
                            enemy.jumpInterval = 60 + Math.random() * 60;
                            enemy.lastJumpX = enemy.x;
                            enemy.lastJumpY = enemy.y;
                            
                            // Create teleport effect
                            createParticles(enemy.x, enemy.y, enemy.color, 10);
                        } else {
                            // Move slowly toward player between jumps
                            enemy.x += (dx / distance) * enemy.speed * 0.3;
                            enemy.y += (dy / distance) * enemy.speed * 0.3;
                        }
                    } else if (enemy.type === ENEMY_TYPES.ZIGZAG) {
                        // Zigzag enemy - moves in a zigzag pattern
                        enemy.zigzagCounter++;
                        if (enemy.zigzagCounter > 30) {
                            // Change zigzag direction
                            enemy.zigzagDir += (Math.random() - 0.5) * Math.PI / 2;
                            enemy.zigzagCounter = 0;
                        }
                        
                        // Move toward player with zigzag offset
                        const towardAngle = Math.atan2(dy, dx);
                        const zigzagAngle = towardAngle + Math.sin(enemy.zigzagCounter / 10) * Math.PI / 3;
                        
                        enemy.x += Math.cos(zigzagAngle) * enemy.speed * 1.2;
                        enemy.y += Math.sin(zigzagAngle) * enemy.speed * 1.2;
                    } else {
                        // Normal enemy - direct movement toward player
                        enemy.x += (dx / distance) * enemy.speed;
                        enemy.y += (dy / distance) * enemy.speed;
                    }
                }

                // Check collision with barriers
                for (let k = barriers.length - 1; k >= 0; k--) {
                    const barrier = barriers[k];
                    const barrierDx = enemy.x - barrier.x;
                    const barrierDy = enemy.y - barrier.y;
                    
                    // Rotate barrier bounds
                    const cos = Math.cos(barrier.angle);
                    const sin = Math.sin(barrier.angle);
                    const rotatedX = barrierDx * cos + barrierDy * sin;
                    const rotatedY = -barrierDx * sin + barrierDy * cos;
                    
                    if (Math.abs(rotatedX) < barrier.width / 2 + enemy.radius &&
                        Math.abs(rotatedY) < barrier.height / 2 + enemy.radius) {
                        // Enemy hits barrier - bounce back
                        const angle = Math.atan2(barrierDy, barrierDx);
                        enemy.x -= Math.cos(angle) * enemy.speed * 2;
                        enemy.y -= Math.sin(angle) * enemy.speed * 2;
                        barrier.life -= 1;
                        
                        if (barrier.life <= 0) {
                            barriers.splice(k, 1);
                            createParticles(barrier.x, barrier.y, '#00ffff', 10);
                        }
                    }
                }
                
                // Check collision with player
                const playerDx = enemy.x - player.x;
                const playerDy = enemy.y - player.y;
                const playerDistance = Math.sqrt(playerDx * playerDx + playerDy * playerDy);

                if (playerDistance < enemy.radius + player.size) {
                    // Player hit!
                    enemies.splice(i, 1);
                    player.health--;
                    createParticles(player.x, player.y, '#ff0000', 15);
                    
                    if (player.health <= 0) {
                        gameOver();
                    }
                }
            }
        }

        // Update particles
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        // Update barriers
        function updateBarriers() {
            for (let i = barriers.length - 1; i >= 0; i--) {
                const barrier = barriers[i];
                barrier.life--;
                
                if (barrier.life <= 0) {
                    barriers.splice(i, 1);
                    createParticles(barrier.x, barrier.y, '#00ffff', 10);
                }
            }
        }

        // Draw functions
        function drawPlayer() {
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.angle);

            // Draw triangle
            ctx.beginPath();
            ctx.moveTo(player.size, 0);
            ctx.lineTo(-player.size, -player.size * 0.8);
            ctx.lineTo(-player.size, player.size * 0.8);
            ctx.closePath();
            
            const gradient = ctx.createLinearGradient(-player.size, 0, player.size, 0);
            gradient.addColorStop(0, player.health > 0 ? '#00ff00' : '#ff0000');
            gradient.addColorStop(1, player.health > 0 ? '#00aa00' : '#aa0000');
            ctx.fillStyle = gradient;
            ctx.fill();
            
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.shadowBlur = 15;
            ctx.shadowColor = player.health > 0 ? '#00ff00' : '#ff0000';
            ctx.stroke();

            ctx.restore();

            // Draw health bar
            const barWidth = 60;
            const barHeight = 8;
            const barX = player.x - barWidth / 2;
            const barY = player.y - player.size - 20;
            
            ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
            ctx.fillRect(barX, barY, barWidth, barHeight);
            
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(barX, barY, barWidth * (player.health / player.maxHealth), barHeight);
            
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.strokeRect(barX, barY, barWidth, barHeight);
        }

        function drawBullets() {
            bullets.forEach(bullet => {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                
                const gradient = ctx.createRadialGradient(
                    bullet.x, bullet.y, 0,
                    bullet.x, bullet.y, bullet.radius
                );
                gradient.addColorStop(0, '#ffff00');
                gradient.addColorStop(1, '#ff8800');
                ctx.fillStyle = gradient;
                ctx.fill();
                
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ffff00';
                ctx.fill();
            });
        }

        function drawEnemies() {
            enemies.forEach(enemy => {
                // Glow effect
                const glowGradient = ctx.createRadialGradient(
                    enemy.x, enemy.y, 0,
                    enemy.x, enemy.y, enemy.radius * 2
                );
                glowGradient.addColorStop(0, enemy.color);
                glowGradient.addColorStop(1, 'transparent');
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.radius * 2, 0, Math.PI * 2);
                ctx.fill();

                // Main circle
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                ctx.fillStyle = enemy.color;
                ctx.fill();
                
                // Inner circle
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.radius * 0.6, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fill();
            });
        }

        function drawParticles() {
            particles.forEach(p => {
                const alpha = p.life / p.maxLife;
                ctx.fillStyle = p.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawBarriers() {
            barriers.forEach(barrier => {
                const alpha = Math.min(1, barrier.life / 600);
                ctx.save();
                ctx.translate(barrier.x, barrier.y);
                ctx.rotate(barrier.angle);
                
                ctx.fillStyle = `rgba(0, 255, 255, ${alpha * 0.5})`;
                ctx.fillRect(-barrier.width / 2, -barrier.height / 2, barrier.width, barrier.height);
                
                ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
                ctx.lineWidth = 2;
                ctx.strokeRect(-barrier.width / 2, -barrier.height / 2, barrier.width, barrier.height);
                
                ctx.restore();
            });
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.1)';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 40) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            drawBarriers();
            drawEnemies();
            drawBullets();
            drawPlayer();
            drawParticles();
            
            // Draw barrier count if available
            if (player.barriers > 0) {
                ctx.fillStyle = '#00ffff';
                ctx.font = '20px Courier New';
                ctx.textAlign = 'left';
                ctx.fillText(`Barriers: ${player.barriers}`, 10, 30);
            }
        }

        // Game loop
        function gameLoop() {
            if (gameRunning) {
                // Update game time
                gameTime = Math.floor((Date.now() - gameStartTime) / 1000);
                document.getElementById('time').textContent = gameTime;
                document.getElementById('enemies').textContent = enemies.length;
                document.getElementById('totalEnemies').textContent = enemiesPerWave;

                // Check for wave completion (all enemies spawned AND all enemies killed)
                if (enemiesSpawned >= enemiesPerWave && enemies.length === 0 && enemiesSpawned > 0 && !waveCompleted && !wavePaused) {
                    waveCompleted = true;
                    showUpgradeSelection();
                }
                
                // Reset wave completion flag when new wave starts spawning (enemies are being spawned again)
                if (waveCompleted && enemiesSpawned > 0 && enemiesSpawned < enemiesPerWave) {
                    waveCompleted = false;
                }

                // Spawn enemies
                const now = Date.now();
                if (now - lastEnemySpawn > enemySpawnRate && enemiesSpawned < enemiesPerWave) {
                    spawnEnemy();
                    lastEnemySpawn = now;
                }

                updatePlayer();
                updateBullets();
                updateEnemies();
                updateBarriers();
                updateParticles();
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        function gameOver() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalTime').textContent = gameTime;
            document.getElementById('finalWave').textContent = wave - 1;
            document.getElementById('gameOver').style.display = 'block';
        }

        // Make resetGame accessible globally
        window.resetGame = function() {
            gameRunning = true;
            wavePaused = false;
            score = 0;
            wave = 1;
            gameTime = 0;
            gameStartTime = Date.now();
            lastEnemySpawn = Date.now();
            lastShotTime = Date.now();
            lastHealTime = Date.now();
            enemySpawnRate = 1500;
            enemiesPerWave = 5;
            enemiesSpawned = 0;
            waveCompleted = false;
            
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            player.health = 3;
            player.maxHealth = 3;
            player.fireRate = 200;
            player.damage = 1;
            player.moveSpeed = 5;
            player.shotMode = 'single';
            player.healOverTime = false;
            player.healLevel = 0;
            player.barriers = 0;
            player.maxBarriers = 0;
            player.fasterBullets = false;
            player.bulletSpeedLevel = 0;
            
            // Reset upgrade levels
            Object.keys(upgradeLevels).forEach(key => delete upgradeLevels[key]);
            
            bullets.length = 0;
            enemies.length = 0;
            particles.length = 0;
            barriers.length = 0;
            
            document.getElementById('score').textContent = score;
            document.getElementById('wave').textContent = wave;
            document.getElementById('totalEnemies').textContent = enemiesPerWave;
            document.getElementById('time').textContent = 0;
            document.getElementById('enemies').textContent = 0;
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('upgradeSelection').style.display = 'none';
        };

        // Initialize - set total enemies display
        document.getElementById('totalEnemies').textContent = enemiesPerWave;
        gameLoop();
    </script>
</body>
</html>
